# Robohand - Raspberry Pi Pico Robotic Hand Controller

## Overview

Robohand is a lightweight, extensible, multithreaded robotic hand control system built for the Raspberry Pi Pico using the Pico SDK and MicroROS library. The system provides a comprehensive interface for controlling servo motors and reading from various sensors, with support for multiple communication interfaces.

## Directory Structure
./Include

├── Robohand_callbacks.h

├── Robohand_common.h

├── Robohand_dma.h

├── Robohand.h

├── Robohand_i2c.h

├── Robohand_init.h

├── Robohand_interrupts.h

├── Robohand_reader.h

├── Robohand_rgb.h

├── Robohand_servos.h

├── Robohand_struct.h

├── Robohand_timing.h

└── Robohand_uros.h

./Src

├── Core

│   ├── Robohand_callbacks.c

│   ├── Robohand_dma.c

│   ├── Robohand_i2c.c

│   ├── Robohand_init.c

│   ├── Robohand_interrupts.c

│   ├── Robohand_reader.c

│   ├── Robohand_rgb.c

│   ├── Robohand_servos.c

│   ├── Robohand_struct.c

│   └── Robohand_timing.c

├── Robohand.c

├── Robohand_uros.c

└── Robohand_usb.c

## Hardware Configuration

The system is designed to work with the following hardware:

- 5 MG996R Servos controlled via PWM on GPIO 11-15
- ADS1115 ADC connected to I2C0 (GPIO 0 & 1)
- BME/P280 pressure/temperature/humidity sensor on I2C0 (optional interrupt on GPIO X)
- MPU6050 accelerometer/gyroscope on I2C0 (optional interrupt on GPIO X)
- QMC5883L magnetometer on I2C0 (optional interrupt on GPIO X)
- Optional Common Cathode RGB LED on GPIO 16-18

## Software Architecture

The code is organized into several modules:
- **Robohand_callbacks.c/h**: Utilizes a series of timer callbacks to mark devices as ready to be read from. Slowest backend.
- **Robohand_dma.c/h**: Utilizes Direct Memory Access to offload device interaction to DMA controllers, the core can retrieve memory from a well known location when DMA signals that the buffer is ready.
- **Robohand_init.c/h**: Initialize device connections, and prepare system for operation.
- **Robohand_interrupts.c/h**: Utilizes signals from a physical interrupt pin to mark devices as ready to be read from. Middle of the line performance suspected.
- **Robohand_i2c.c/h**: I2C initialization, error checking, and utility functions. Uses Pico SDK
- **Robohand.c/h**: Core system hardware implementation, providing the interface to physical hardware via Pico SDK.
- **Robohand_usb.c**: Provides a terminal interface for monitoring and controlling the hand over USB.
- **Robohand_uros.c/h**: MicroROS client implementation for ROS integration.

The system runs on dual cores:
- **Core 0**: Handles communication with host systems (USB or MicroROS)
- **Core 1**: Manages hardware I/O, sensor polling, and servo control

## Features

- **Multithreaded Design**: Utilizes both cores of the RP2040 for parallel processing
- **Flexible Communication**: USB terminal interface or ROS integration via MicroROS
- **Comprehensive Sensor Support**: Read from multiple sensors over I2C
- **Smooth Motion Control**: Implements trapezoidal motion profiles for servo control
- **Safety Features**: Watchdog timer, emergency stop functionality, mutex protection
- **Multiple Backend Options**: Choose between interrupt-based, DMA, or callback-based communication

## Configuration Options

The system can be configured by modifying the defines in `Robohand.h`:

```c
#define HAS_ADS1115 true    // Enable ADS1115 ADC
#define HAS_BME280 true     // Enable BME280 sensor
#define HAS_QMC5883L true   // Enable QMC5883L magnetometer
#define HAS_MPU6050 true    // Enable MPU6050 IMU
#define HAS_PI_ADC false    // Enable Pico's internal ADC
#define HAS_RGB true        // Enable RGB LED indicator
#define HAS_SERVOS true     // Enable servo control

#define USE_INTERRUPTS false // Use interrupt-based communication
#define USE_DMA false        // Use DMA-based communication
#define USE_CALLBACKS true   // Use callback-based communication
```

## Building the Project

### Prerequisites

- Raspberry Pi Pico SDK (v1.4.0 or later)
- CMake (v3.13 or later)
- GCC ARM toolchain
- MicroROS library (for ROS integration)

### Setup

1. Clone the repository:
   ```bash
   git clone https://github.com/yourusername/robohand.git
   cd robohand
   ```

2. Create a build directory:
   ```bash
   mkdir build
   cd build
   ```

3. Configure and build:
   ```bash
   cmake ..
   make
   ```

This will build two targets:
- `Robohand_usb.uf2` - USB terminal interface
- `Robohand_uros.uf2` - MicroROS interface

### Flashing

1. Hold the BOOTSEL button on the Pico while connecting it to the computer
2. Copy the desired .uf2 file to the mounted Pico drive:
   ```bash
   cp Robohand_usb.uf2 /media/username/RPI-RP2/
   ```

## Usage

### USB Terminal Interface

Connect to the Pico's USB serial port:
```bash
screen /dev/ttyACM0 115200
```

Available commands:
- `status` - Display system status
- `sensors` - Show current sensor readings
- `servo <index> <position> <duration>` - Move a servo
- `rgb <r> <g> <b>` - Set RGB LED color
- `blink <on|off> <interval>` - Control LED blinking
- `help` - Show available commands

### MicroROS Interface

When using the MicroROS build, the system will automatically connect to a MicroROS agent and advertise the following topics:

- `/robohand/servos` - Control servos
- `/robohand/sensors` - Publish sensor data
- `/robohand/status` - Publish system status

## Performance Considerations

- **Servo Control**: For smooth motion, keep update intervals below 20ms
- **Sensor Polling**: Using interrupts or DMA reduces CPU load but increases complexity
- **Memory Usage**: The system uses static allocation for critical structures to avoid heap fragmentation

## Troubleshooting

- **Terminal Backspacing Issues**: Make sure to use the latest build with CRLF fixes
- **Servo Jittering**: Check power supply stability and reduce update frequency
- **I2C Communication Failures**: Verify wiring and pull-up resistors
- **System Crashes**: Enable watchdog timer and check for mutex deadlocks

## License

This project is licensed under the Apache 2.0 License - see the LICENSE file for details.

## Author

Robert Fudge <rnfudge@mun.ca>

## Acknowledgments

- Raspberry Pi Foundation for the Pico SDK
- MicroROS team for embedded ROS supportThe projects tree representation is given below.

./Include
├── Robohand_callbacks.h
├── Robohand_common.h
├── Robohand_dma.h
├── Robohand.h
├── Robohand_i2c.h
├── Robohand_init.h
├── Robohand_interrupts.h
├── Robohand_reader.h
├── Robohand_rgb.h
├── Robohand_servos.h
├── Robohand_struct.h
├── Robohand_timing.h
└── Robohand_uros.h
./Src
├── Core
│   ├── Robohand_callbacks.c
│   ├── Robohand_dma.c
│   ├── Robohand_i2c.c
│   ├── Robohand_init.c
│   ├── Robohand_interrupts.c
│   ├── Robohand_reader.c
│   ├── Robohand_rgb.c
│   ├── Robohand_servos.c
│   ├── Robohand_struct.c
│   └── Robohand_timing.c
├── Robohand.c
├── Robohand_uros.c
└── Robohand_usb.c

1 directory, 13 files

/*!
 * \file Robohand_callbacks.h
 * \brief Simple, straightforward callback backend.
 * \details Uses repeating timers to coortidnate device read access.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_CALLBACKS_H
#define ROBOHAND_CALLBACKS_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#define USE_CALLBACKS true                                      ///< Use interupts for system communication

/**
 * @defgroup callbacks Timer Callback Functions
 * @brief Functions for timer-based sensor polling
 * @{
 */
void init_callbacks(void);
/** @} */

#ifdef __cplusplus
}
#endif

#endif // ROBOHAND_CALLBACKS_H/*!
 * \file Robohand_common.h
 * \brief Common macros needed by multiple files.
 * \details Try to keep code isolated to various files.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_COMMON_H
#define ROBOHAND_COMMON_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#define HAS_PI_ADC false                                        ///< Whether a pressure sensor is connected to the pi pico
#define HAS_ADC false                                           ///< Whether or not ADC initalization is required

#define ADC2_PIN 28                                             ///< GPIO pin for Pico's ADC channel 2
#define NUM_SERVOS 5                                            ///< Number of servos to control
#define DEBUG 1                                                 ///< Enable debug output, higher levels increase verbosity

#define SYS_CLOCK 125000000                                     ///< System operating frequency

#define NUM_PRESPNTS 5                                          ///< Number of pressure points to sample

#ifdef __cplusplus
}
#endif

#endif/*!
 * \file Robohand_dma.h
 * \brief Robohand DMA backend, complicated, extremely performant.
 * \details Work in progress featureset.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_DMA_H
#define ROBOHAND_DMA_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#define USE_DMA false                                           ///< Use DMA for system communication

/** @defgroup dma_config DMA Configuration
 *  @brief Constants and definitions for DMA operations.
 *  @{
 */
 
#define DMA_CHANNEL_I2C 0                                       ///< DMA channel for I2C transfers
#define DMA_CHANNEL_ADC 1                                       ///< DMA channel for ADC transfers
#define DMA_ADC_SAMPLES 256                                     ///< Number of ADC samples per DMA transfer
#define DMA_IN_USE 4                                            ///< Number of channels to use for DMA
#define I2C_DMA_TX DREQ_I2C0_TX                                 ///< I2C DMA TX channel
#define I2C_DMA_RX DREQ_I2C0_RX                                 ///< I2C DMA RX channel
  
/** @} */ // end of dma_config

/**
 * @defgroup dma DMA Handler Functions
 * @brief Functions to initialize and manage DMA operations
 * @{
 */
void init_dma(void);
void read_adc_data(void);
/** @} */

#ifdef __cplusplus
}
#endif

#endif // ROBOHAND_DMA_H/*!
* \file Robohand.h
* \brief Robotic hand control hardware interface.
* \details Used for other robohand modules, which each handle different methods of connection.
* \author Robert Fudge <rnfudge@mun.ca>
* \date 2025
* \copyright Apache 2.0 License
*/

#ifndef ROBOHAND_H
#define ROBOHAND_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

//Includes


//Allows the system to use the correct built-in LED
#if defined(PICO_BOARD_pico_w) || defined(PICO_BOARD_IS_PICO_W)

#include "pico/cyw43_arch.h"
#define ROBOHAND_LED_PIN CYW43_WL_GPIO_LED_PIN

#else

#define ROBOHAND_LED_PIN 25                                     ///< Pin to use for heartbeat callback   

#endif

#ifndef WATCHDOG_IRQ

#define WATCHDOG_IRQ 1                                          ///< Needed for watchdog intervention

#endif

//Global variables
extern const float VOLTAGE_DIVIDER_RATIO;                   ///< Voltage divider ratio (1:1)

/** @defgroup system_init System Initialization Functions
 *  @brief Functions for initializing the robotic hand system.
 *  @{
 */

/*!
 * @brief Initializes the robotic hand system and launches Core 1.
 * @details Performs critical system initialization including:
 *          - Mutex initialization for shared data
 *          - Core 1 launch for hardware I/O operations
 * @pre This should be run from core 0.
 * @post Core 1 handles sensor polling, servo control, and system monitoring.
 */
void init_robohand_system(void);



/** @} */ // end of system_init

/*!
 * @brief Core 1 main execution loop.
 * @details Handles all hardware-related operations:
 *          - Sensor polling (accelerometer, gyroscope, magnetometer)
 *          - ADC sampling
 *          - Servo control
 *          - System status monitoring
 * @pre The system has been initialized.
 * @note Runs indefinitely after system initialization.
 */
void core1_entry(void);

/*!
 * @brief Gets debug information about the system.
 * @details Prints out detailed system status and diagnostics to serial output.
 */
void get_debug_info(void);

/** @} */ // end of system_status

/** @defgroup sensor_operations Sensor Operations
 *  @brief Functions for sensor reading and processing.
 *  @{
 */

/*!
 * @brief Reads sensor data based on operation flags.
 * @details Handles all sensor read operations as triggered by flags.
 */
void robohand_read(void);

/*!
 * @brief Retrieves and prints diagnostic information.
 * @details Displays I2C status, sensor readings, and system health.
 */
void retrieve_debug_info(void);

/** @} */ // end of sensor_operations

#ifdef __cplusplus
}
#endif

#endif //ROBOHAND_H/*!
 * \file Robohand_i2c.h
 * \brief Provides I2C integration and utility functions.
 * \details Provides I2C, DMA, and sensor-specific functionality.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_I2C_H
#define ROBOHAND_I2C_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdatomic.h>
#include <stdint.h>

#include "hardware/i2c.h"
#include "pico/mutex.h"

/** @defgroup i2c_flags I2C Operation Flags
 *  @brief Flags used to signal required I2C operations.
 *  @{
 */
#define ADC_READ_FLAG (1 << 0)                                  ///< Bit signalling an ADC read is needed over the I2C bus
#define BME_READ_FLAG (1 << 1)                                  ///< Bit signalling a BME read is needed
#define MPU_READ_FLAG (1 << 2)                                  ///< Bit signalling a MPU read is needed over the I2C bus
#define QMC_READ_FLAG (1 << 3)                                  ///< Bit signalling a QMC read is needed over the I2C bus
  
/** @} */ // end of i2c_flags

/** @defgroup i2c_const I2C Constants
 *  @brief Constants used in driver code.
 *  @{
 */

#define HAS_ADS1115 false                                       ///< Whether the ADS1115 (ADC) is connected to the I2C bus
#define HAS_BME280 true                                         ///< Whether the BME280 altitude sensor is connected to the I2C bus
#define HAS_QMC5883L true                                       ///< Whether the QMC5883L (Magnometer) is connected to the i2c bus
#define HAS_MPU6050 true                                        ///< Whether the MPU6050 (Accelerometer) is connected to the i2c bus
#define HAS_I2C true                                            ///< Whether or not I2C initialization is required

#define I2C_PORT i2c0                                           ///< I2C port used for device connections(i2c0 on pico)
#define SDA_PIN 0                                               ///< GPIO pin for I2C SDA
#define SCL_PIN 1                                               ///< GPIO pin for I2C SCL

//I2C Addresses
#define ADS1115_ADDR 0x48                                       ///< I2C address of ADS1115 ADC
#define BME280_ADDR 0x76                                        ///< I2C address of BME280 pressure sensor
#define MPU6050_ADDR 0x68                                       ///< I2C address of MPU6050 IMU
#define QMC5883L_ADDR 0x0D                                      ///< I2C address of QMC5883L magnetometer

//QMC5883L Registers
#define QMC5883L_CONFIG_A 0x00                                  ///< Configuration register A
#define QMC5883L_CONFIG_B 0x01                                  ///< Configuration register B
#define QMC5883L_MODE 0x02                                      ///< Mode register
#define QMC5883L_DATA 0x03                                      ///< Data output register

#define QMC5883L_MODE_CONTINUOUS 0x00                           ///< Continious sampling mode

//ADS1115 Configuration Macros
#define ADS1115_OS_SINGLE   0x8000                              ///< Start single-conversion
#define ADS1115_MUX_AIN0    0x4000                              ///< AIN0 vs GND
#define ADS1115_MUX_AIN1    0x5000                              ///< AIN1 vs GND
#define ADS1115_MUX_AIN2    0x6000                              ///< AIN2 vs GND
#define ADS1115_MUX_AIN3    0x7000                              ///< AIN3 vs GND
#define ADS1115_FSR_4V096   0x0200                              ///< ±4.096V range
#define ADS1115_MODE_SINGLE 0x0100                              ///< Single-shot mode
#define ADS1115_DR_128SPS   0x0080                              ///< 128 samples/sec
#define ADS1115_COMP_MODE   0x0000                              ///< Traditional comparator
#define ADS1115_COMP_POL    0x0000                              ///< Active low
#define ADS1115_COMP_LAT    0x0000                              ///< Non-latching
#define ADS1115_COMP_QUE    0x0003                              ///< Disable comparator

#define ADS1115_BASE_CONFIG (ADS1115_OS_SINGLE | ADS1115_FSR_4V096 | ADS1115_MODE_SINGLE | \
    ADS1115_DR_128SPS | ADS1115_COMP_MODE | ADS1115_COMP_POL | \
    ADS1115_COMP_LAT | ADS1115_COMP_QUE)                        ///< ADS1115 base configuration

//MPU6050 Registers
#define MPU6050_ACCEL_XOUT_H 0x3B                               ///< Accelerometer data register

/** @} */ // end of i2c_const

extern _Atomic uint8_t i2c_operation_flags;
extern mutex_t i2c_mutex;

/**
 * @defgroup i2c_utils I2C Utility Functions
 * @brief Helper functions for I2C communication
 * @{
 */
void robohand_init_i2c(void);
bool i2c_write_with_retry(uint8_t addr, const uint8_t* src, size_t len, bool retain_bus, uint64_t timeout);
bool i2c_read_with_retry(uint8_t addr, uint8_t* dest, size_t len, bool retain_bus, uint64_t timeout);
bool i2c_read_reg(uint8_t dev_addr, uint8_t reg_addr, uint8_t* data, size_t len);
bool i2c_write_reg(uint8_t dev_addr, uint8_t reg_addr, uint8_t value);
void i2c_scan_bus(void);
bool i2c_check_devices(void);
bool i2c_check_ads1115(void);
bool i2c_check_bme280(void);
bool i2c_check_mpu6050(void);
bool i2c_check_qmc5883l(void);
void i2c_recover_bus(void);
/** @} */

#ifdef __cplusplus
}
#endif

#endif // ROBOHAND_I2C_H/*!
 * \file Robohand_init.h
 * \brief Initializes connected peripherals to well-known state.
 * \details Change register values to modify configuration.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_INIT_H
#define ROBOHAND_INIT_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>

/**
 * @defgroup initialization Hardware Initialization Functions
 * @brief Functions to initialize various hardware components
 * @{
 */

/*!
 * @brief Initializes all hardware components based on configuration.
 * @details Sets up I2C, sensors, and communication backends.
 * @return True if all enabled components initialized successfully, false otherwise.
 */
bool robohand_init_components(void);

/** @} */

#ifdef __cplusplus
}
#endif

#endif/*!
 * \file Robohand_interrupts.h
 * \brief Interrupt backend, for balance of power with complexity.
 * \details Still a work-in-progress.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_INTERRUPTS_H
#define ROBOHAND_INTERRUPTS_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>
#include "pico/stdlib.h"

#define USE_INTERRUPTS false                                    ///< Use interupts for system communication

#define ADS1115_INT_PIN 22                                      ///< Data ready pin for the ADS1115
#define BME280_INT_PIN 21                                       ///< Data ready pin for the BME280
#define MPU6050_INT_PIN 20                                      ///< Data ready pin for the MPU6050 
#define QMC5883L_INT_PIN 19                                     ///< Data ready pin for the QMC5883L

/**
 * @defgroup interrupts Interrupt Handler Functions
 * @brief Functions to initialize and handle hardware interrupts
 * @{
 */
void init_interrupts(void);
static void ads1115_drdy_handler(uint gpio, uint32_t events);
static void bme280_drdy_handler(uint gpio, uint32_t events);
static void gy271_drdy_handler(uint gpio, uint32_t events);
static void mpu6050_drdy_handler(uint gpio, uint32_t events);
/** @} */

#ifdef __cplusplus
}
#endif

#endif // ROBOHAND_INTERRUPTS_H/*!
 * \file Robohand_reader.h
 * \brief Contains reader functions for sensor access.
 * \details Reader functions are called via the chosen backend.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_READER_H
#define ROBOHAND_READER_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

/**
 * @defgroup sensor_readers Sensor Reader Functions
 * @brief Functions to read data from various sensors
 * @{
 */
uint16_t read_ads_channel(int channel);
float ads_voltage(uint16_t raw);
void read_bme280_calibration(void);
void compensate_bme280_data(const uint8_t* raw_data, float* temperature,
    float* pressure, float* humidity, float* altitude);
bool read_bme280_data(void);
bool read_mpu6050_data(void);
bool read_qmc5883l_data(void);
/** @} */

#ifdef __cplusplus
}
#endif

#endif // ROBOHAND_READER_H/*!
 * \file Robohand_rgb.h
 * \brief Interface for using Common Cathode LED for user feedback.
 * \details Ensure initialization is complete before using interactors.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_RGB_H
#define ROBOHAND_RGB_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>

#define HAS_RGB true                                            ///< Whether common Cathode RGB LED is connected to the pi pico

#define RGB_RED_PIN 18                                          ///< GPIO pin connected to the red channel
#define RGB_GREEN_PIN 17                                        ///< GPIO pin connected to the green channel
#define RGB_BLUE_PIN 16                                         ///< GPIO pin connected to the blue channel

/** @defgroup rgb_control RGB LED Control Functions
 *  @brief Functions for controlling RGB LED.
 *  @{
 */

/*!
 * @brief Initializes the RGB LED subsystem.
 * @details Configures PWM hardware and initializes mutexes.
 */
void init_rgb(void);

/*!
 * @brief Sets the RGB LED color.
 * @param[in] r Red component (0-255).
 * @param[in] g Green component (0-255).
 * @param[in] b Blue component (0-255).
 */
void rgb_set_color(uint8_t r, uint8_t g, uint8_t b);

/*!
 * @brief Sets the brightness of RGB LED.
 * @param brightness Brightness level (0.0-1.0).
 */
void rgb_set_brightness(float brightness);

/*!
 * @brief Configures the RGB to blink at a specified interval.
 * @param enable Enable or disable blinking.
 * @param interval_ms Blink interval in milliseconds.
 */
void rgb_blink(bool enable, uint32_t interval_ms);

/** @} */ // end of rgb_control

#ifdef __cplusplus
}
#endif

#endif
/*!
 * \file Robohand_servos.h
 * \brief Provides servo functionality for user control.
 * \details Utilizes PWM, may upgrade to DMA in the future to reduce latency.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_SERVOS_H
#define ROBOHAND_SERVOS_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdbool.h>
#include <stdint.h>

#include "pico/mutex.h"

#include "Robohand_common.h"
#include "Robohand_struct.h"

#define HAS_SERVOS false                                        ///< Whether servos are connected to the device

#define SERVO_MIN_PULSE 500                                     ///< Lower threshold for pulse time
#define SERVO_MAX_PULSE 2500                                    ///< Upper threshold for pulse time
#define MAX_MOVE_DURATION_MS 15000                              ///< Max amount of time the motor is allowed to move over before timeout
#define SERVO_PWM_FREQ 50                                       ///< Desired frequency for PWM response
#define CLK_DIV 64.f                                            ///< Clock divisor used for PWM
#define WRAP_VAL ((SYS_CLOCK / (SERVO_PWM_FREQ * CLK_DIV)) - 1) ///< 125MHz divided by the clock divider and the desired frequency. Will loop from 0 - calculated value

#define MAX_SERVO_ACCEL 2500                                    ///< µs/s² (adjust for servo dynamics)

extern const uint SERVO_PINS[NUM_SERVOS];

extern mutex_t servo_mutex;

/** @defgroup servo_control Servo Control Functions
 *  @brief Functions for controlling servo motors.
 *  @{
 */

/*!
 * @brief Actuates a servo to a specified position over a given duration.
 * @param servo Servo index (0 to NUM_SERVOS-1).
 * @param pulse_width Target pulse width in microseconds (500-2500µs).
 * @param duration_ms Movement duration in milliseconds.
 */
void actuate_servo(uint8_t servo, uint16_t pulse_width, uint16_t duration_ms);

/*!
 * @brief Constrains a 16-bit value between minimum and maximum bounds.
 * @param value The value to constrain.
 * @param min The minimum allowed value.
 * @param max The maximum allowed value.
 * @return The constrained value.
 */
uint16_t constrain_u16(uint16_t value, uint16_t min, uint16_t max);

/*!
 * @brief Retrieves the current status of a servo.
 * @param[in] servo Servo index (0 to NUM_SERVOS-1).
 * @param[out] dest Pointer to servo_motion_profile to populate.
 * @return True if successfully acquired, false if error.
 * @note An error in this case could simply be that the mutexes could not be acquired
 */
bool get_servo_status(uint8_t servo, servo_motion_profile* dest);

void handle_servo_commands(uint32_t cmd);
void update_servo_positions(void);
void init_servo_pwm(void);

/** @} */ // end of servo_control

#ifdef __cplusplus
}
#endif

#endif/*!
 * \file Robohand_struct.h
 * \brief Contains functions for interacting with system structures.
 * \details Will set clearly invalid values on init (planned).
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_STRUCT_H
#define ROBOHAND_STRUCT_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdatomic.h>                                          ///< Needed for atomic instructions
#include <stdbool.h>                                            ///< For bool struct members
#include <stdint.h>                                             ///< For uintX_t struct members

#include "pico/mutex.h"                                         ///< For Mutex struct members

#include "Robohand_common.h"

/** @defgroup dma_structures DMA Structures
 *  @brief Structures for managing DMA operations.
 *  @{
 */
 
/*!
 * @brief Structure for storing the data for a DMA channel.
 * @details Contains the channel ID, whether the request is complete, and its IRQ status.
 */
typedef struct {
    int channel;                                                ///< DMA channel number
    atomic_bool complete;                                       ///< Flag indicating if transfer is complete
    uint32_t irq_status;                                        ///< IRQ status of the channel
} dma_channel_state;

/*!
 * @brief Structure for storing system DMA configuration.
 * @details Stores state of all DMA channels
 */
typedef struct {
    dma_channel_state i2c_tx;                                   ///< I2C transmit DMA channel state
    dma_channel_state i2c_rx;                                   ///< I2C receive DMA channel state
    dma_channel_state adc;                                      ///< ADC DMA channel state
    dma_channel_state pwm;                                      ///< PWM DMA channel state
} dma_control_t;

/** @} */ // end of dma_structures

/** @defgroup system_structs System Structures
 *  @brief Structures used during program execution. Eases development with safe, lockable access to resources.
 *  @note Mutexes contain spinlock (type io_rw_32) and bool (uint8_t), to be safe insert 3-bytes padding at the end.
 *  @{
 */

/*!
 * @brief Structure for RGB LED configuration and state.
 * @details Stores current color, brightness, and synchronization primitives.
 */
typedef struct {
    bool blink_active;                                      ///< Whether blinking is active
    bool blink_state;                                       ///< Current state of the blink (on/off)
    uint8_t current_r;                                      ///< Current red value (0-255)
    uint8_t current_g;                                      ///< Current green value (0-255)
    uint8_t current_b;                                      ///< Current blue value (0-255)
    uint8_t __p0;                                           ///< Maintaining alignment for next uint16_t access
    uint16_t pwm_wrap;                                      ///< PWM wrap value for frequency control
    uint32_t blink_interval;                                ///< Blink interval in milliseconds
    float current_brightness;                               ///< Current brightness (0.0-1.0)
    mutex_t rgb_mutex;                                      ///< Mutex for color/brightness access
    uint8_t __p1[3];                                        ///< Mutex is struct containing io_rw_32 and bool, maintain 32-bit alignment
    mutex_t pwm_mutex;                                      ///< Mutex for PWM hardware access, unaligned access to io_rw_32 will cause a fault
    uint8_t __p2[3];                                        ///< Mutex is struct containing io_rw_32 and bool, maintain 32-bit alignment
} rgb_state;

/*!
 * @brief Sensor data structure with mutex protection.
 * @details Contains sensor readings from accelerometer, gyroscope, magnetometer, and ADCs.
 * @pre Acquire mutex before performing any read/write on this structure.
 */
typedef struct {
    int16_t accel[3];                                       ///< Accelerometer readings (X, Y, Z)
    uint8_t __p3[2];                                        ///< Padding for explicit 32-bit alignment (DMA)
    int16_t gyro[3];                                        ///< Gyroscope readings (X, Y, Z)
    uint8_t __p4[2];                                        ///< Padding for explicit 32-bit alignment (DMA)
    int16_t mag[3];                                         ///< Magnetometer readings (X, Y, Z)
    uint8_t __p5[2];                                        ///< Padding for explicit 32-bit alignment
    float adc_values[5];                                    ///< ADC readings (channels 0-3 + internal ADC2)
    float pressure;                                         ///< Air pressure in Pascals
    float altitude;                                         ///< Altitude in meters
    float temperature;                                      ///< Temperature in degrees Celsius
    float humidity;                                         ///< Humidity percentage (0-100%)
    mutex_t data_mutex;                                     ///< Mutex for thread-safe data access
    uint8_t __p6[3];                                        ///< Mutex is struct containing io_rw_32 and bool, maintain 32-bit alignment
} sensor_data;

/*!
 * @brief Physical sensor data structure.
 * @details Contains converted sensor readings in physical units.
 * @note Doesn't need to be used on core 1, technically doesn't need mutex, also not involved with any callbacks.
 */
typedef struct {
    float accel[3];                                         ///< Accelerometer in g (9.81 m/s²)
    float gyro[3];                                          ///< Gyroscope in degrees per second (dps)
    float mag[3];                                           ///< Magnetometer in microteslas (µT)
    float adc_values[5];                                    ///< ADC readings in volts or converted units
    float altitude;                                         ///< Altitude estimation in meters
    mutex_t data_mutex;                                     ///< Mutex for thread-safe data access
    uint8_t __p10[3];                                       ///< Mutex is struct containing io_rw_32 and bool, maintain 32-bit alignment
} sensor_data_physical;

/*!
 * @brief Servo motion profile structure.
 * @details Stores parameters for smooth servo movement using trapezoidal profiles.
 * @note Maintains explicit alignment for 32-bit boundaries
 */
typedef struct {
    uint8_t pin;                                            ///< Pin to use for PWM modulation
    bool is_moving;                                         ///< Movement status flag
    uint16_t current_pw;                                    ///< Current pulse width (µs)
    uint16_t target_pw;                                     ///< Target pulse width (µs)
    uint16_t duration_ms;                                   ///< Total movement duration (ms)
    uint32_t start_time;                                    ///< Movement start timestamp (µs)
    mutex_t profile_mutex;                                  ///< Mutex for safe access
    uint8_t __p11[3];                                       ///< Mutex is struct containing io_rw_32 and bool, maintain 32-bit alignment
} servo_motion_profile;

/*!
 * @brief Status data structure.
 * @details Contains information about system health.
 * @pre Acquire mutex before performing any read/write on this structure.
 */
typedef struct {
    uint32_t core0_loops;                                   ///< Counts on core 0 main loop since last status retrieval
    uint32_t core1_loops;                                   ///< Counts on core 1 main loop since last status retrieval
    uint32_t last_update;                                   ///< Last time the counter was reset on core 0
    float core0_load;                                       ///< Approximation of load on core 0
    float core1_load;                                       ///< Approximation of load on core 1
    uint32_t last_watchdog;                                 ///< Time since last watchdog event
    bool system_ok;                                         ///< Did the watchdog reset the system?
    bool emergency_stop;                                    ///< To be used for automatic servo stoppage
    uint8_t __p12[2];                                       ///< Make sure io_rw_32 access is on 32-bit boundary
    mutex_t status_mutex;                                   ///< Mutex to protect access to internal members
    uint8_t __p13[3];                                       ///< Mutex is struct containing io_rw_32 and bool, maintain 32-bit alignment
} system_status;

/** @} */ // end of system_structs

 /** @defgroup sensor_structures Sensor-Specific Structures
  *  @brief Structures specific to sensor operations.
  *  @{
  */
 
 /*!
  * @brief Structure to hold BME280 calibration data.
  * @details Contains all calibration coefficients needed for temperature, pressure, and humidity.
  */
 typedef struct {
    uint16_t dig_T1;                       ///< Temperature calibration T1
    int16_t dig_T2;                        ///< Temperature calibration T2
    int16_t dig_T3;                        ///< Temperature calibration T3
    uint16_t dig_P1;                       ///< Pressure calibration P1
    int16_t dig_P2;                        ///< Pressure calibration P2
    int16_t dig_P3;                        ///< Pressure calibration P3
    int16_t dig_P4;                        ///< Pressure calibration P4
    int16_t dig_P5;                        ///< Pressure calibration P5
    int16_t dig_P6;                        ///< Pressure calibration P6
    int16_t dig_P7;                        ///< Pressure calibration P7
    int16_t dig_P8;                        ///< Pressure calibration P8
    int16_t dig_P9;                        ///< Pressure calibration P9
    uint8_t dig_H1;                        ///< Humidity calibration H1
    int16_t dig_H2;                        ///< Humidity calibration H2
    uint8_t dig_H3;                        ///< Humidity calibration H3
    int16_t dig_H4;                        ///< Humidity calibration H4
    int16_t dig_H5;                        ///< Humidity calibration H5
    int8_t dig_H6;                         ///< Humidity calibration H6
} bme280_calib_data;

/** @} */ // end of sensor_structures

extern bme280_calib_data bme280_calib;
extern rgb_state rgb_conf;
extern sensor_data sensor_readings;
extern servo_motion_profile servo_profiles[NUM_SERVOS];     ///< Data structure array for holding servo profiles
extern system_status sys_status;                            ///< System status data structure instance

/** @defgroup system_status System Status Functions
 *  @brief Functions for retrieving system status information.
 *  @{
 */

/*!
 * @brief Retrieves the current status of the system.
 * @param[out] dest Pointer to system_status structure to populate.
 */
void get_system_status(system_status* dest);

/** @defgroup sensor_data Sensor Data Functions
 *  @brief Functions for retrieving and processing sensor data.
 *  @{
 */

/*!
 * @brief Retrieves current sensor data in a thread-safe manner.
 * @param[out] dest Pointer to sensor_data structure to receive readings.
 * @return true if data copied successfully, false if mutex was busy.
 * @pre dest points to a valid sensor_data object.
 * @warning Caller must allocate destination buffer. Data valid until next update.
 */
bool get_sensor_data(sensor_data* dest);

/*!
 * @brief Converts passed sensor data to physical parameters.
 * @param[in] raw Pointer to sensor_data structure to containing unconverted values.
 * @param[out] converted Pointer to sensor_data_physical structure to receive readings as physical parameters.
 * @return true if data copied successfully, false if mutex was busy.
 * @warning Caller must allocate destination buffer. Data valid until next update.
 */
bool convert_sensor_data(const sensor_data* raw, sensor_data_physical* converted);

/** @} */ // end of sensor_data

void destroy_rgb_state_struct(rgb_state* rgb_struct);
void destroy_sensor_data_struct(sensor_data* sensor_struct);
void destroy_sensor_data_physical_struct(sensor_data_physical* sensor_struct);
void destroy_servo_motion_profile_struct(servo_motion_profile* servo_profile);
void destroy_system_status_struct(system_status* sys_status);

void init_rgb_state_struct(rgb_state* rgb_struct);
void init_sensor_data_struct(sensor_data* sensor_struct);
void init_sensor_data_physical_struct(sensor_data_physical* sensor_struct);
void init_servo_motion_profile_struct(servo_motion_profile* servo_profile, uint8_t pwm_pin);
void init_system_status_struct(system_status* sys_status);

#ifdef __cplusplus
}
#endif

#endif // ROBOHAND_STRUCT_H/*!
 * \file Robohand_timing.h
 * \brief Timing functionality for performance evaluation.
 * \details Only fucntional when the debugging flag is > 0.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#ifndef ROBOHAND_TIMING_H
#define ROBOHAND_TIMING_H

//Ensure C++ compatibility
#ifdef __cplusplus
extern "C" {
#endif

#include <stdint.h>

#include "Robohand_common.h"

#if DEBUG > 0
    uint32_t timing_start(void);
    void timing_end(const char* func_name, uint32_t start_time);
    void timing_print_report(void);
    void timing_init(void);
#else
    static inline uint32_t timing_start(void) {
        return 0;
    }

    static inline void timing_end(const char* func_name, uint32_t start_time) { 
        (void)func_name; (void)start_time;
    }

    static inline void timing_print_report(void) {

    }

    static inline void timing_init(void) {

    }

#endif

#ifdef __cplusplus
}
#endif

#endif/*!
 * @file Robohand_uros.h
 * @brief MicroROS interface header for robotic hand control system.
 * @details Defines structures and functions for MicroROS communication.
 * @author Robert Fudge <rnfudge@mun.ca>
 * @date 2025
 * @copyright Apache 2.0 License
 */

#ifndef ROBOHAND_UROS_H
#define ROBOHAND_UROS_H

#ifdef __cplusplus
extern "C" {
#endif

#include "Robohand.h"

// MicroROS topic names
#define TOPIC_SERVO_CMD    "robohand/servo"
#define TOPIC_SENSOR_DATA  "robohand/sensors"
#define TOPIC_SYSTEM_STATUS "robohand/status"

// Custom message type definitions (if needed)
// For now, we're using standard ROS2 messages

// Function prototypes
void uros_init(void);
void uros_spin(void);
void uros_shutdown(void);

#ifdef __cplusplus
}
#endif

#endif // ROBOHAND_UROS_H/*!
 * \file Robohand_callbacks.c
 * \brief Simple, straightforward callback backend.
 * \details Uses repeating timers to coortidnate device read access.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#include "Robohand.h"
#include "Robohand_callbacks.h"
#include "Robohand_common.h"
#include "Robohand_i2c.h"

#include <stdatomic.h>

/** 
 * @brief Timer for ADC callback (Default 100ms / 10Hz)
 */
static struct repeating_timer adc_timer;

/** 
 * @brief Timer for BME280 pressure sensor (Default 100ms / 10Hz)
 */
static struct repeating_timer bme_timer;

/** 
 * @brief Timer for QMC5883L callback (Default 50ms / 20Hz)
 */
static struct repeating_timer gy271_timer;

/** 
 * @brief Timer for MPU6050 callback (Default 100ms / 10Hz)
 */
static struct repeating_timer mpu_timer;

/**
 * @defgroup callbacks Timer Callback Functions
 * @brief Functions for timer-based sensor polling
 * @{
 */
static bool adc_sample_callback(struct repeating_timer* t);
static bool bme280_callback(struct repeating_timer* t);
static bool gy271_callback(struct repeating_timer* t);
static bool mpu6050_callback(struct repeating_timer* t);
/** @} */

/**
 * @brief Initialize timer-based sensor data acquisition
 */
void init_callbacks(void) {
    if (HAS_PI_ADC || HAS_ADS1115) {
        add_repeating_timer_ms(-100, &adc_sample_callback, NULL, &adc_timer); // 10Hz - 100ms
    }
    
    if (HAS_BME280) {
        add_repeating_timer_ms(-100, &bme280_callback, NULL, &bme_timer); // 10Hz - 100ms
    }
    
    if (HAS_MPU6050) {
        add_repeating_timer_ms(-50, &mpu6050_callback, NULL, &mpu_timer); // 20Hz - 50ms
    }

    if (HAS_QMC5883L) {
        add_repeating_timer_ms(-100, &gy271_callback, NULL, &gy271_timer); // 10Hz - 100ms
    }
}

/**
 * @brief Timer callback for ADC data acquisition
 * 
 * @param t Pointer to the repeating timer structure
 * @return true to continue timer, false to stop
 */
static bool adc_sample_callback(struct repeating_timer* t) {
    (void)t;    // Cast to void to avoid static analysis errors

    if (HAS_ADC) {
        uint8_t expected = i2c_operation_flags;
        uint8_t desired = expected | ADC_READ_FLAG;
        atomic_compare_exchange_strong(&i2c_operation_flags, &expected, desired);

        return true;
    }

    else {
        return false;
    }
}

/**
 * @brief Timer callback for BME280 data acquisition
 * 
 * @param t Pointer to the repeating timer structure
 * @return true to continue timer, false to stop
 */
static bool bme280_callback(struct repeating_timer* t) {
    (void)t;    // Cast to void to avoid static analysis errors

    if (HAS_BME280) {
        uint8_t expected = i2c_operation_flags;
        uint8_t desired = expected | BME_READ_FLAG;
        atomic_compare_exchange_strong(&i2c_operation_flags, &expected, desired);

        return true;
    }

    else {
        return false;
    }
}

/**
 * @brief Timer callback for MPU6050 data acquisition
 * 
 * @param t Pointer to the repeating timer structure
 * @return true to continue timer, false to stop
 */
static bool mpu6050_callback(struct repeating_timer* t) {
    (void)t;    // Cast to void to avoid static analysis errors

    if (HAS_MPU6050) {
        uint8_t expected = i2c_operation_flags;
        uint8_t desired = expected | MPU_READ_FLAG;
        atomic_compare_exchange_strong(&i2c_operation_flags, &expected, desired);

        return true;
    }

    else {
        return false;
    }
}

/**
 * @brief Timer callback for QMC5883L data acquisition
 * 
 * @param t Pointer to the repeating timer structure
 * @return true to continue timer, false to stop
 */
static bool gy271_callback(struct repeating_timer* t) {
    (void)t;    // Cast to void to avoid static analysis errors

    if (HAS_QMC5883L) {
        uint8_t expected = i2c_operation_flags;
        uint8_t desired = expected | QMC_READ_FLAG;
        atomic_compare_exchange_strong(&i2c_operation_flags, &expected, desired);

        return true;
    }

    else {
        return false;
    }
}
/*!
 * \file Robohand_dma.c
 * \brief Robohand DMA backend, very complicated, extremely performant.
 * \details Work in progress featureset.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#include "Robohand.h"
#include "Robohand_dma.h"
#include "Robohand_i2c.h"
#include "Robohand_reader.h"
#include "Robohand_struct.h"

#include "hardware/adc.h"
#include "hardware/dma.h"
#include "hardware/irq.h"
#include "hardware/i2c.h"

#include <stdio.h>
#include <stdlib.h>

typedef int channel_id;

/** 
 * @brief Buffer for storing MPU6050 accelerometer and gyroscope data
 */
static uint8_t mpu_buffer[14];

/**
 * @brief Buffer for storing ADC samples
 */
static uint16_t adc_buffer[DMA_ADC_SAMPLES];

/**
 * @brief DMA channel for PWM operations
 */
static int pwm_dma_chan;

/**
 * @brief DMA channel for ADC operations
 */
static int adc_dma_chan;

/**
 * @brief DMA channel for I2C transmit operations
 */
static int i2c_tx_dma_chan;

/**
 * @brief DMA channel for I2C receive operations
 */
static int i2c_rx_dma_chan;

/**
 * @brief DMA control structure for managing different DMA channels
 */
static dma_control_t dma_control;

/**
 * @defgroup dma DMA Handler Functions
 * @brief Functions to initialize and manage DMA operations
 * @{
 */
static void process_adc_samples(const uint16_t* samples);
static void __isr dma_adc_handler(void);
static bool read_mpu6050_data_dma(void);
static void start_adc_dma_sampling(void);
static uint16_t read_ads1115_dma(int channel);
/** @} */

/**
 * @brief Initialize DMA channels for different peripherals
 */
void init_dma(void) {
    // Claim DMA channels correctly
    dma_control.i2c_tx.channel = dma_claim_unused_channel(true);
    dma_control.i2c_rx.channel = dma_claim_unused_channel(true);
    dma_control.adc.channel = dma_claim_unused_channel(true);
    dma_control.pwm.channel = dma_claim_unused_channel(true);
    
    // Initialize completion flags
    atomic_store(&dma_control.i2c_tx.complete, true);
    atomic_store(&dma_control.i2c_rx.complete, true);
    atomic_store(&dma_control.adc.complete, true);
    atomic_store(&dma_control.pwm.complete, true);
    
    if (DEBUG > 0) {
        printf("DMA channels assigned: TX=%d, RX=%d, ADC=%d, PWM=%d\r\n", 
            dma_control.i2c_tx.channel, dma_control.i2c_rx.channel, 
            dma_control.adc.channel, dma_control.pwm.channel);
    }
    
    // Configure I2C TX DMA channel
    dma_channel_config tx_config = dma_channel_get_default_config(dma_control.i2c_tx.channel);
    channel_config_set_transfer_data_size(&tx_config, DMA_SIZE_8);
    channel_config_set_dreq(&tx_config, i2c_get_dreq(I2C_PORT, true));
    channel_config_set_read_increment(&tx_config, true);
    channel_config_set_write_increment(&tx_config, false);
    dma_channel_configure(
        dma_control.i2c_tx.channel,
        &tx_config,
        &i2c_get_hw(I2C_PORT)->data_cmd, // Write to I2C data register
        NULL,  // Source address (set later)
        0,     // Transfer count (set later)
        false  // Don't start yet
    );
    
    // Configure I2C RX DMA channel
    dma_channel_config rx_config = dma_channel_get_default_config(dma_control.i2c_rx.channel);
    channel_config_set_transfer_data_size(&rx_config, DMA_SIZE_8);
    channel_config_set_dreq(&rx_config, i2c_get_dreq(I2C_PORT, false));
    channel_config_set_read_increment(&rx_config, false);
    channel_config_set_write_increment(&rx_config, true);
    dma_channel_configure(
        dma_control.i2c_rx.channel,
        &rx_config,
        NULL,  // Destination address (set later)
        &i2c_get_hw(I2C_PORT)->data_cmd, // Read from I2C data register
        0,     // Transfer count (set later)
        false  // Don't start yet
    );
    
    // Configure ADC DMA if needed
    if (HAS_PI_ADC) {
        adc_fifo_setup(true, true, 1, false, false); // Enable FIFO, threshold 1, no error bit
        
        dma_channel_config adc_config = dma_channel_get_default_config(dma_control.adc.channel);
        channel_config_set_transfer_data_size(&adc_config, DMA_SIZE_16);
        channel_config_set_read_increment(&adc_config, false);
        channel_config_set_write_increment(&adc_config, true);
        channel_config_set_dreq(&adc_config, DREQ_ADC);
        
        // Set up IRQ handler
        dma_channel_set_irq0_enabled(dma_control.adc.channel, true);
        irq_set_exclusive_handler(DMA_IRQ_0, dma_adc_handler);
        irq_set_enabled(DMA_IRQ_0, true);
        
        dma_channel_configure(
            dma_control.adc.channel,
            &adc_config,
            adc_buffer,      // Destination buffer
            &adc_hw->fifo,   // Source: ADC FIFO
            DMA_ADC_SAMPLES, // Number of samples
            false            // Don't start yet
        );
    }
}

/**
 * @brief Interrupt handler for ADC DMA completion
 */
static void __isr dma_adc_handler(void) {
    // Clear the interrupt request for the ADC channel
    if (dma_channel_get_irq0_status(dma_control.adc.channel)) {
        dma_channel_acknowledge_irq0(dma_control.adc.channel);
        
        // Signal completion
        dma_control.adc.complete = true;
        
        // Process the samples
        process_adc_samples(adc_buffer);
    }
}

/**
 * @brief Process the DMA-acquired ADC samples
 * 
 * @param samples Pointer to buffer containing the ADC samples
 */
static void process_adc_samples(const uint16_t *samples) {
    if (!samples) return;
    
    uint32_t sum = 0;
    
    // Average all samples
    for (int i = 0; i < DMA_ADC_SAMPLES; i++) {
        sum += samples[i];
    }
    
    float average = (float)sum / DMA_ADC_SAMPLES;
    float voltage = average * 3.3f / 4096.0f; // 12-bit ADC with 3.3V reference
    
    // Update sensor data thread-safely
    if (mutex_enter_timeout_ms(&sensor_readings.data_mutex, 50)) {
        sensor_readings.adc_values[4] = voltage;
        mutex_exit(&sensor_readings.data_mutex);
    }
    
    if (DEBUG > 1) {
        printf("ADC DMA sampling complete: avg=%f, voltage=%.3fV\r\n", average, voltage);
    }
}

void read_adc_data(void) {
    static int current_channel = 0;

    if (HAS_ADS1115) {
        int raw = ~0;
        if (USE_DMA) {
            raw = read_ads1115_dma(current_channel);
        }
        
        else {
           raw = read_ads_channel(current_channel);
        }
        
        float voltage = ads_voltage((uint16_t) abs(raw));
        
        mutex_enter_blocking(&sensor_readings.data_mutex);
        sensor_readings.adc_values[current_channel] = voltage;
        mutex_exit(&sensor_readings.data_mutex);

        current_channel = (current_channel + 1) % 4;
        
        // Start next conversion
        uint16_t config = (uint16_t) (ADS1115_BASE_CONFIG | (0x4000 | (current_channel << 12)));
        uint8_t config_bytes[2] = {config >> 8, config & 0xFF};
        i2c_write_with_retry(ADS1115_ADDR, config_bytes, 2, true, 2000);
    }

    // Read Pico's ADC2
    if (HAS_PI_ADC) {
        adc_select_input(2);
        float adc2_val = adc_read() * 3.3f / 4096.0f;
        mutex_enter_blocking(&sensor_readings.data_mutex);
        sensor_readings.adc_values[4] = adc2_val;
        mutex_exit(&sensor_readings.data_mutex);
    }
}

/**
 * @brief Read MPU6050 data using DMA transfer
 * 
 * @return true if read was successful, false otherwise
 */
static bool read_mpu6050_data_dma(void) {
    if (!HAS_MPU6050) return false;
    
    if (!mutex_try_enter(&i2c_mutex, NULL)) {
        return false;
    }
    
    // Check if DMA is already in progress
    if (!atomic_load(&dma_control.i2c_tx.complete) || !atomic_load(&dma_control.i2c_rx.complete)) {
        mutex_exit(&i2c_mutex);
        return false;
    }
    
    // Prepare the register address (0x3B - ACCEL_XOUT_H)
    static uint8_t reg_addr = MPU6050_ACCEL_XOUT_H;
    
    // Mark DMA as in use
    atomic_store(&dma_control.i2c_tx.complete, false);
    atomic_store(&dma_control.i2c_rx.complete, false);
    
    // Configure TX DMA to write register address
    dma_channel_set_read_addr(dma_control.i2c_tx.channel, &reg_addr, 1);
    dma_channel_set_trans_count(dma_control.i2c_tx.channel, 1, true);
    
    // Wait for TX to complete
    dma_channel_wait_for_finish_blocking(dma_control.i2c_tx.channel);
    
    // Configure RX DMA to read data
    dma_channel_set_write_addr(dma_control.i2c_rx.channel, mpu_buffer, 14);
    dma_channel_set_trans_count(dma_control.i2c_rx.channel, 14, true);
    
    // Wait for RX to complete
    dma_channel_wait_for_finish_blocking(dma_control.i2c_rx.channel);
    
    // Mark DMA as complete
    atomic_store(&dma_control.i2c_tx.complete, true);
    atomic_store(&dma_control.i2c_rx.complete, true);
    
    // Clear the I2C interrupt
    uint8_t int_status_reg = 0x3A;
    uint8_t int_status;
    i2c_write_blocking(I2C_PORT, MPU6050_ADDR, &int_status_reg, 1, true);
    i2c_read_blocking(I2C_PORT, MPU6050_ADDR, &int_status, 1, false);
    
    mutex_exit(&i2c_mutex);
    
    // Process the data
    if (mutex_enter_timeout_ms(&sensor_readings.data_mutex, 50)) {
        // Process accelerometer data (bytes 0-5)
        sensor_readings.accel[0] = (int16_t)((mpu_buffer[0] << 8) | mpu_buffer[1]);
        sensor_readings.accel[1] = (int16_t)((mpu_buffer[2] << 8) | mpu_buffer[3]);
        sensor_readings.accel[2] = (int16_t)((mpu_buffer[4] << 8) | mpu_buffer[5]);
        
        // Process gyroscope data (bytes 8-13)
        sensor_readings.gyro[0] = (int16_t)((mpu_buffer[8] << 8) | mpu_buffer[9]);
        sensor_readings.gyro[1] = (int16_t)((mpu_buffer[10] << 8) | mpu_buffer[11]);
        sensor_readings.gyro[2] = (int16_t)((mpu_buffer[12] << 8) | mpu_buffer[13]);
        
        mutex_exit(&sensor_readings.data_mutex);
        return true;
    }
    
    return false;
}

/**
 * @brief Start ADC sampling using DMA transfer
 */
static void start_adc_dma_sampling(void) {
    if (!HAS_PI_ADC || !USE_DMA) return;
    
    // Check if DMA is already in progress
    if (!dma_control.adc.complete) {
        return;
    }
    
    // Mark DMA as in use
    dma_control.adc.complete = false;
    
    // Select ADC input
    adc_select_input(2); // ADC2 - channel configured as ADC2_PIN
    
    // Start the ADC in free-running mode
    adc_run(true);
    
    // Start the DMA transfer
    dma_channel_start(dma_control.adc.channel);
}

/**
 * @brief Read ADS1115 channel using DMA transfer
 * 
 * @param channel ADS1115 channel to read (0-3)
 * @return Raw 16-bit ADC value
 */
/**
 * @brief Read ADS1115 channel using DMA transfer
 * 
 * @param channel ADS1115 channel to read (0-3)
 * @return Raw 16-bit ADC value
 */
static uint16_t read_ads1115_dma(int channel) {
    if (!HAS_ADS1115 || !USE_DMA) {
        return 0xFFFF;
    }
    
    if (!mutex_try_enter(&i2c_mutex, NULL)) {
        return 0xFFFF;
    }
    
    // Check if DMA is already in progress
    if (!atomic_load(&dma_control.i2c_tx.complete) || !atomic_load(&dma_control.i2c_rx.complete)) {
        mutex_exit(&i2c_mutex);
        return 0xFFFF;
    }
    
    // Configure ADS1115 for the selected channel
    uint16_t config = (uint16_t) (ADS1115_BASE_CONFIG | (0x4000 | (channel << 12)));
    uint8_t config_bytes[3] = {0x01, (uint8_t) (config >> 8), (uint8_t) (config & 0xFF)};
    
    // Mark DMA as in use
    atomic_store(&dma_control.i2c_tx.complete, false);
    
    // Configure and start TX DMA to write config register
    dma_channel_set_read_addr(dma_control.i2c_tx.channel, config_bytes, 3);
    dma_channel_set_trans_count(dma_control.i2c_tx.channel, 3, true);
    
    // Wait for TX to complete
    dma_channel_wait_for_finish_blocking(dma_control.i2c_tx.channel);
    atomic_store(&dma_control.i2c_tx.complete, true);
    
    // Conversion time (worst case ~8ms for 128SPS)
    sleep_ms(10);
    
    // Prepare to read conversion register (0x00)
    uint8_t conv_reg = 0x00;
    atomic_store(&dma_control.i2c_tx.complete, false);
    
    // Configure and start TX DMA to write conversion register address
    dma_channel_set_read_addr(dma_control.i2c_tx.channel, &conv_reg, 1);
    dma_channel_set_trans_count(dma_control.i2c_tx.channel, 1, true);
    
    // Wait for TX to complete
    dma_channel_wait_for_finish_blocking(dma_control.i2c_tx.channel);
    atomic_store(&dma_control.i2c_tx.complete, true);
    
    // Read the conversion result
    uint8_t result[2];
    atomic_store(&dma_control.i2c_rx.complete, false);
    
    // Configure and start RX DMA to read conversion result
    dma_channel_set_write_addr(dma_control.i2c_rx.channel, result, 2);
    dma_channel_set_trans_count(dma_control.i2c_rx.channel, 2, true);
    
    // Wait for RX to complete
    dma_channel_wait_for_finish_blocking(dma_control.i2c_rx.channel);
    atomic_store(&dma_control.i2c_rx.complete, true);
    
    mutex_exit(&i2c_mutex);
    
    // Combine the bytes into a 16-bit result
    return (uint16_t) ((result[0] << 8) | result[1]);
}/*!
 * \file Robohand_i2c.c
 * \brief Provides I2C integration and utility functions.
 * \details Provides I2C, DMA, and sensor-specific functionality.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#include "Robohand.h"
#include "Robohand_i2c.h"

#include "hardware/i2c.h"
#include "pico/mutex.h"
#include "pico/stdlib.h"

#include <stdio.h>
#include <stdatomic.h>

/**
 * @brief Atomic flag register for coordinating I2C access
 * @details May change at any point due to interrupt handlers
 */
_Atomic uint8_t i2c_operation_flags = 0;

/**
 * @brief Mutex to protect I2C bus access from concurrent operations
 */
mutex_t i2c_mutex;
static uint32_t i2c_mutex_owner = 0;
static uint32_t i2c_mutex_acquire_time = 0;

bool safe_mutex_enter(mutex_t *mutex, uint32_t timeout_ms, const char *function_name) {
    bool success;
    if (timeout_ms == 0) {
        mutex_enter_blocking(mutex);
        success = true;
    } else {
        success = mutex_enter_timeout_ms(mutex, timeout_ms);
    }
    
    if (success) {
        i2c_mutex_owner = (uint32_t)function_name;
        i2c_mutex_acquire_time = time_us_32();
        if (DEBUG > 0) {
            printf("I2C mutex acquired by %s at %lu\r\n", function_name, i2c_mutex_acquire_time);
        }
    } else if (DEBUG > 0) {
        printf("Failed to acquire I2C mutex in %s (currently owned by %s for %lu us)\r\n", 
               function_name, (const char*)i2c_mutex_owner, 
               time_us_32() - i2c_mutex_acquire_time);
    }
    
    return success;
}

// Replace mutex_exit for i2c_mutex with this
void safe_mutex_exit(mutex_t *mutex, const char *function_name) {
    if (DEBUG > 0) {
        printf("I2C mutex released by %s after %lu us\r\n", 
               function_name, time_us_32() - i2c_mutex_acquire_time);
    }
    i2c_mutex_owner = 0;
    mutex_exit(mutex);
}

/**
 * @brief Initializes the I2C interface with appropriate configuration
 */
void robohand_init_i2c(void) {
    if (DEBUG > 0) {
        printf("Initializing I2C.\r\n");
    }

    i2c_init(I2C_PORT, 400000);
    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(SDA_PIN);
    gpio_pull_up(SCL_PIN);
    i2c_scan_bus();
    mutex_init(&i2c_mutex);

    if (DEBUG > 0) {
        printf("I2C initialized.\r\n");
    }
}

/**
 * @brief Write to I2C device with retry mechanism
 * 
 * @param addr I2C device address
 * @param src Source data buffer
 * @param len Length of data to write
 * @param retain_bus Whether to retain control of the bus after transaction
 * @param timeout Timeout in microseconds
 * @return true if write was successful, false otherwise
 */
bool i2c_read_with_retry(uint8_t addr, uint8_t* dest, size_t len, bool retain_bus, uint64_t timeout) {
    if (!HAS_I2C || !dest) return false;
    
    const int MAX_RETRIES = 3;
    int retries = MAX_RETRIES;
    
    while (retries > 0) {
        int result = i2c_read_blocking_until(I2C_PORT, addr, dest, len, retain_bus, time_us_64() + timeout);
        
        if (result == len) {
            return true;  // Success
        }
        
        // Log specific error types
        if (DEBUG > 0) {
            if (result == PICO_ERROR_TIMEOUT) {
                printf("I2C[0x%02X]: Read timeout (%d retries left)\r\n", addr, retries-1);
            } else if (result == PICO_ERROR_GENERIC) {
                printf("I2C[0x%02X]: Read generic error (%d retries left)\r\n", addr, retries-1);
            } else if (result >= 0 && result < len) {
                printf("I2C[0x%02X]: Incomplete read %d/%d bytes (%d retries left)\r\n", 
                    addr, result, len, retries-1);
            } else {
                printf("I2C[0x%02X]: Read unknown error %d (%d retries left)\r\n", 
                       addr, result, retries-1);
            }
        }
        
        // Add exponential backoff for retries
        sleep_ms(5 * (1 << (MAX_RETRIES - retries)));
        retries--;
    }
    
    // All retries failed
    if (DEBUG > 0) {
        printf("I2C[0x%02X]: Read failed after %d attempts\r\n", addr, MAX_RETRIES);
    }
    
    return false;
}

/**
 * @brief Read from a specific register on an I2C device
 * 
 * @param dev_addr I2C device address
 * @param reg_addr Register address to read from
 * @param data Buffer to store read data
 * @param len Length of data to read
 * @return true if read was successful, false otherwise
 */
bool i2c_read_reg(uint8_t dev_addr, uint8_t reg_addr, uint8_t* data, size_t len) {
    if (!safe_mutex_enter(&i2c_mutex, 100, "i2c_read_reg")) {
        if (DEBUG > 0) {
            printf("i2c_read_reg: Failed to acquire mutex\r\n");
        }
        return false;
    }
    
    bool write_success = i2c_write_with_retry(dev_addr, &reg_addr, 1, true, 5000);
    if (!write_success && DEBUG > 0) {
        printf("i2c_read_reg: Failed to write register address 0x%02X to device 0x%02X\r\n", 
               reg_addr, dev_addr);
    }
    
    bool read_success = false;
    if (write_success) {
        read_success = i2c_read_with_retry(dev_addr, data, len, false, 5000);
        if (!read_success && DEBUG > 0) {
            printf("i2c_read_reg: Failed to read %d bytes from device 0x%02X register 0x%02X\r\n", 
                   len, dev_addr, reg_addr);
        }
    }
    
    safe_mutex_exit(&i2c_mutex, "i2c_read_reg");
    return write_success && read_success;
}

/*!
 * @brief Write to the I2C port with retry mechanism.
 * @param addr I2C device address.
 * @param src Source buffer containing data to write.
 * @param len Number of bytes to write.
 * @param retain_bus Whether to retain the bus for subsequent operations.
 * @param timeout Operation timeout in microseconds.
 * @return True if write succeeded, false otherwise.
 */
bool i2c_write_with_retry(uint8_t addr, const uint8_t* src, size_t len, bool retain_bus, uint64_t timeout) {
    if (!HAS_I2C || !src) return false;
    
    const int MAX_RETRIES = 3;
    int retries = MAX_RETRIES;
    
    while (retries > 0) {
        int result = i2c_write_blocking_until(I2C_PORT, addr, src, len, retain_bus, time_us_64() + timeout);
        
        if (result == len) {
            return true;  // Success
        }
        
        // Log specific error types with consistent format
        if (DEBUG > 0) {
            if (result == PICO_ERROR_TIMEOUT) {
                printf("I2C[0x%02X]: Timeout error (%d retries left)\r\n", addr, retries-1);
            } else if (result == PICO_ERROR_GENERIC) {
                printf("I2C[0x%02X]: Generic error (%d retries left)\r\n", addr, retries-1);
            } else if (result >= 0 && result < len) {
                printf("I2C[0x%02X]: Incomplete write %d/%d bytes (%d retries left)\r\n", 
                       addr, result, len, retries-1);
            } else {
                printf("I2C[0x%02X]: Unknown error %d (%d retries left)\r\n", 
                       addr, result, retries-1);
            }
        }
        
        // Add exponential backoff for retries
        sleep_ms(5 * (1 << (MAX_RETRIES - retries)));
        retries--;
    }
    
    // All retries failed
    if (DEBUG > 0) {
        printf("I2C[0x%02X]: Write failed after %d attempts\r\n", addr, MAX_RETRIES);
    }
    
    return false;
}

/**
 * @brief Write to a specific register on an I2C device
 * 
 * @param dev_addr I2C device address
 * @param reg_addr Register address to write to
 * @param value Value to write
 * @return true if write was successful, false otherwise
 */
bool i2c_write_reg(uint8_t dev_addr, uint8_t reg_addr, uint8_t value) {
    uint8_t data[2] = {reg_addr, value};
    
    if (!safe_mutex_enter(&i2c_mutex, 100, "i2c_write_reg")) {
        return false;
    }
    
    bool success = i2c_write_with_retry(dev_addr, data, 2, false, 5000);
    
    safe_mutex_exit(&i2c_mutex, "i2c_write_reg");
    return success;
}

/**
 * @brief Scan I2C bus for connected devices
 */
void i2c_scan_bus(void) {
    printf("\r\nScanning I2C bus:\r\n");
    bool found_any = false;
    
    for (uint8_t addr = 0; addr < 128; addr++) {
        uint8_t dummy = 0;
        int ret = i2c_write_blocking(I2C_PORT, addr, &dummy, 1, false);
        if (ret >= 0) {
            found_any = true;
            printf("  Device found at address 0x%02X", addr);
            
            // Identify known devices
            if (addr == BME280_ADDR) printf(" (BME280)");
            if (addr == MPU6050_ADDR) printf(" (MPU6050)");
            if (addr == QMC5883L_ADDR) printf(" (QMC5883L)");
            if (addr == ADS1115_ADDR) printf(" (ADS1115)");
            
            printf("\r\n");
        }
    }
    
    if (!found_any) {
        printf("  No I2C devices found! Check wiring.\r\n");
    }
    printf("\r\n");
}

/**
 * @brief Check if all configured I2C devices are responding
 * 
 * @return true if all devices are responsive, false otherwise
 */
bool i2c_check_devices(void) {   
    bool all_ok = true;

    if (!HAS_I2C) {
        return true;
    }
    
    if (safe_mutex_enter(&i2c_mutex, 50, "i2c_check_devices")) {

        all_ok = all_ok && i2c_check_ads1115();
        all_ok = all_ok && i2c_check_bme280();
        all_ok = all_ok && i2c_check_mpu6050();
        all_ok = all_ok && i2c_check_qmc5883l();
        
        safe_mutex_exit(&i2c_mutex, "i2c_check_devices");
    }
    
    else {
        if (DEBUG > 0) {
            printf("Failed to acquire I2C mutex for device check\r\n");
        }
        all_ok = false;
    }
    
    return all_ok;
}

/**
 * @brief Check if ADS1115 is responding
 * 
 * @return true if device is responsive, false otherwise
 */
bool i2c_check_ads1115(void) {
    bool all_ok = true;
    uint8_t dummy;

    if (HAS_ADS1115 && i2c_read_blocking_until(I2C_PORT, ADS1115_ADDR, &dummy, 1, false, time_us_64() + 1000) != 1) {
        if (DEBUG > 0) {
            printf("ADS1115 not responding\r\n");
        }

        all_ok = false;
    }

    return all_ok;
}

/**
 * @brief Check if BME280 is responding
 * 
 * @return true if device is responsive, false otherwise
 */
bool i2c_check_bme280(void) {
    bool all_ok = true;
    uint8_t dummy;

    if (HAS_BME280 && i2c_read_blocking_until(I2C_PORT, BME280_ADDR, &dummy, 1, false, time_us_64() + 1000) != 1) {
        if (DEBUG > 0) {
            printf("BME280 not responding\r\n");
        }

        all_ok = false;
    }

    return all_ok;
}

/**
 * @brief Check if MPU6050 is responding
 * 
 * @return true if device is responsive, false otherwise
 */
bool i2c_check_mpu6050(void) {
    bool all_ok = true;
    uint8_t dummy;

    if (HAS_MPU6050 && i2c_read_blocking_until(I2C_PORT, MPU6050_ADDR, &dummy, 1, false, time_us_64() + 1000) != 1) {
        if (DEBUG > 0) {
            printf("MPU6050 not responding\r\n");
        }

        all_ok = false;
    }

    return all_ok;
}

/**
 * @brief Check if QMC5883L is responding
 * 
 * @return true if device is responsive, false otherwise
 */
bool i2c_check_qmc5883l(void) {
    bool all_ok = true;
    uint8_t dummy;

    if (HAS_QMC5883L && i2c_read_blocking_until(I2C_PORT, QMC5883L_ADDR, &dummy, 1, false, time_us_64() + 1000) != 1) {
        if (DEBUG > 0) {
            printf("QMC5883L not responding\r\n");
        }

        all_ok = false;
    }

    return all_ok;
}

/**
 * @brief Attempt to recover I2C bus in case of issues
 */
void i2c_recover_bus(void) {
    if (!HAS_I2C) return;
    
    if (DEBUG > 0) {
        printf("Attempting I2C bus recovery\r\n");
    }
    
    // First, reinitialize the I2C hardware
    i2c_deinit(I2C_PORT);
    sleep_ms(50);
    i2c_init(I2C_PORT, 400000);
    
    // Toggle SCL manually to unstick any devices
    gpio_set_function(SCL_PIN, GPIO_FUNC_SIO);
    gpio_set_function(SDA_PIN, GPIO_FUNC_SIO);
    gpio_set_dir(SCL_PIN, GPIO_OUT);
    gpio_set_dir(SDA_PIN, GPIO_OUT);
    
    // Send 9 clock pulses to reset any stuck devices
    for (int i = 0; i < 9; i++) {
        gpio_put(SCL_PIN, 0);
        sleep_us(5);
        gpio_put(SCL_PIN, 1);
        sleep_us(5);
    }
    
    // Send STOP condition
    gpio_put(SDA_PIN, 0);
    sleep_us(5);
    gpio_put(SCL_PIN, 1);
    sleep_us(5);
    gpio_put(SDA_PIN, 1);
    sleep_us(5);
    
    // Restore I2C function
    gpio_set_function(SDA_PIN, GPIO_FUNC_I2C);
    gpio_set_function(SCL_PIN, GPIO_FUNC_I2C);
    gpio_pull_up(SDA_PIN);
    gpio_pull_up(SCL_PIN);
    
    if (DEBUG > 0) {
        printf("I2C bus recovery completed\r\n");
    }
}
#include "Robohand_i2c.h"
#include "Robohand_init.h"
#include "Robohand_dma.h"
#include "Robohand_callbacks.h"
#include "Robohand_common.h"
#include "Robohand_interrupts.h"
#include "Robohand_reader.h"

#include "pico/time.h"
#include "hardware/adc.h"
#include "hardware/gpio.h"

#include <stdio.h>

/**
 * @defgroup initialization Hardware Initialization Functions
 * @brief Functions to initialize various hardware components
 * @{
 */

static void robohand_init_backend(void);
static bool robohand_init_ads1115(void);
static void robohand_init_bme280(void);
static bool robohand_init_mpu6050(void);
static bool robohand_configure_mpu6050(void);
static bool robohand_init_qmc5883l(void);

/** @} */

/**
 * @brief Performs a periodic health check of the system
 * 
 * @details Checks I2C devices and attempts recovery if necessary
 */
void robohand_health_check(void) {
    static uint32_t last_check_time = 0;
    static uint32_t i2c_error_count = 0;
    static bool recovery_in_progress = false;
    
    uint32_t now = time_us_32();
    
    // Only check every 5 seconds to avoid excessive overhead
    if (now - last_check_time < 5000000 && !recovery_in_progress) {
        return;
    }
    
    last_check_time = now;
    
    // Check if I2C devices are responding
    if (HAS_I2C && !i2c_check_devices()) {
        i2c_error_count++;
        
        if (i2c_error_count >= 3 && !recovery_in_progress) {
            // Too many errors, attempt recovery
            recovery_in_progress = true;
            i2c_recover_bus();
            
            // Re-initialize the sensors
            if (HAS_ADS1115) robohand_init_ads1115();
            if (HAS_BME280) robohand_init_bme280();
            if (HAS_MPU6050) robohand_init_mpu6050();
            if (HAS_QMC5883L) robohand_init_qmc5883l();
            
            recovery_in_progress = false;
            i2c_error_count = 0;
            
            if (DEBUG > 0) {
                printf("I2C bus recovery completed\r\n");
            }
        }
    } else {
        // All good, reset error count
        i2c_error_count = 0;
    }
}

/**
 * @brief Initializes all hardware components based on configuration flags
 * 
 * @return true if initialization was successful, false otherwise
 */
bool robohand_init_components(void) {
    bool success = true;
    
    // Initialize Pico ADCs if enabled
    if (HAS_PI_ADC) {
        if (DEBUG > 0) {
            printf("Initializing Pico ADCs\r\n");
        }
        
        adc_init();
        adc_gpio_init(ADC2_PIN);
        
        if (DEBUG > 0) {
            printf("Pico ADCs initialized\r\n");
        }
    }
    
    //Init backend I2C connection
    robohand_init_backend();
    
    // Initialize individual sensors
    if (HAS_ADS1115) {
        success &= robohand_init_ads1115();
    }
    
    if (HAS_BME280) {
        robohand_init_bme280();
    }
    
    if (HAS_MPU6050 && !robohand_init_mpu6050()) {
        if (DEBUG > 0) {
            printf("MPU6050 initialization failed, retrying...\r\n");
        }
        sleep_ms(100);

        if (!robohand_init_mpu6050()) {
            if (DEBUG > 0) {
                printf("MPU6050 initialization failed again\r\n");
            }
            success = false;
        }
    }
    
    if (HAS_QMC5883L && !robohand_init_qmc5883l()) {
        if (DEBUG > 0) {
            printf("QMC5883L initialization failed, retrying...\r\n");
        }
        sleep_ms(100);
        if (!robohand_init_qmc5883l()) {
            if (DEBUG > 0) {
                printf("QMC5883L initialization failed again\r\n");
            }
            success = false;
        }
    }
    
    return success;
}

/**
 * @brief Initializes the systems reading backend, including I2C
 * @details Used for coordinating resource access
 * @pre Only one USE_X flag is set in the macro configuration
 * @post Desired backend will be used
 */
static void robohand_init_backend(void) {
    // Initialize I2C
    if (HAS_I2C) {
        robohand_init_i2c();
    }

    // Initialize DMA if enabled
    if (USE_DMA) {
        if (DEBUG > 0) {
            printf("Initializing DMA backend\r\n");
        }
    
        init_dma();
    
        if (DEBUG > 0) {
            printf("DMA backend initialized\r\n");
        }
    }

    // Configure appropriate data acquisition method
    if (USE_INTERRUPTS) {
        if (DEBUG > 0) {
            printf("Initializing interrupt backend\r\n");
        }
    
        init_interrupts();
    
        if (DEBUG > 0) {
            printf("Interrupt backend initialized\r\n");
        }
    }
    else if (USE_CALLBACKS) {
        if (DEBUG > 0) {
            printf("Initializing callback backend\r\n");
        }
    
        init_callbacks();
    
        if (DEBUG > 0) {
            printf("Callback backend initialized\r\n");
        }
    }
}

/**
 * @brief Initializes the MPU6050 accelerometer and gyroscope
 * @pre System is operating in a single core fashion, to prevent race conditions and resource conflicts
 * @return true if initialization was successful, false otherwise
 */
static bool robohand_init_mpu6050(void) {
    if (!HAS_MPU6050) return false;
    
    if (DEBUG > 0) {
        printf("Configuring MPU6050...\r\n");
    }
    
    // Reset device
    if (!i2c_write_reg(MPU6050_ADDR, 0x6B, 0x80)) { // PWR_MGMT_1, reset bit
        if (DEBUG > 0) {
            printf("Failed to reset MPU6050\r\n");
        }
        return false;
    }
    
    sleep_ms(100); // Wait for reset
    
    // Wake up device and select best clock source
    if (!i2c_write_reg(MPU6050_ADDR, 0x6B, 0x01)) { // PWR_MGMT_1, clock source = PLL with X-axis gyro
        if (DEBUG > 0) {
            printf("Failed to wake up MPU6050\r\n");
        }
        return false;
    }
    
    sleep_ms(10);
    
    // Disable sleep mode
    if (!i2c_write_reg(MPU6050_ADDR, 0x6C, 0x00)) { // PWR_MGMT_2, enable all axes
        if (DEBUG > 0) {
            printf("Failed to disable sleep mode on MPU6050\r\n");
        }
        return false;
    }

    bool ret = robohand_configure_mpu6050();

    if (ret == false) {
        return false;
    }
    
    // Verify WHO_AM_I register (should be 0x68)
    uint8_t who_am_i = 0;
    if (i2c_read_reg(MPU6050_ADDR, 0x75, &who_am_i, 1)) {
        if (who_am_i != 0x68) {
            if (DEBUG > 0) {
                printf("MPU6050 WHO_AM_I returned 0x%02X (expected 0x68)\r\n", who_am_i);
            }
            return false;
        }
    } else {
        if (DEBUG > 0) {
            printf("Failed to read MPU6050 WHO_AM_I register\r\n");
        }
        return false;
    }
    
    if (DEBUG > 0) {
        printf("MPU6050 configuration successful, WHO_AM_I = 0x%02X\r\n", who_am_i);
    }
    
    return true;
}

/**
 * @brief Configures the MPU6050 accelerometer and gyroscope
 * @details Writes to configuration registers
 * @pre System is operating in a single core fashion, to prevent race conditions and resource conflicts
 * @return true if initialization was successful, false otherwise
 */
static bool robohand_configure_mpu6050(void) {
    // Configure gyro for ±250 dps range
    if (!i2c_write_reg(MPU6050_ADDR, 0x1B, 0x00)) { // GYRO_CONFIG
        if (DEBUG > 0) {
            printf("Failed to configure MPU6050 gyro range\r\n");
        }
        return false;
    }

    // Configure accel for ±2g range
    if (!i2c_write_reg(MPU6050_ADDR, 0x1C, 0x00)) { // ACCEL_CONFIG
        if (DEBUG > 0) {
            printf("Failed to configure MPU6050 accel range\r\n");
        }
        return false;
    }

    // Configure digital low-pass filter
    if (!i2c_write_reg(MPU6050_ADDR, 0x1A, 0x03)) { // CONFIG, DLPF_CFG=3 (42Hz bandwidth)
        if (DEBUG > 0) {
            printf("Failed to configure MPU6050 DLPF\r\n");
        }
        return false;
    }

    // Configure sample rate divider
    if (!i2c_write_reg(MPU6050_ADDR, 0x19, 0x04)) { // SMPLRT_DIV (1000 / (1 + 4) = 200Hz)
        if (DEBUG > 0) {
            printf("Failed to configure MPU6050 sample rate\r\n");
        }
        return false;
    }

    // Configure interrupts
    if (!i2c_write_reg(MPU6050_ADDR, 0x37, 0x20)) { // INT_PIN_CFG: clear on read
        if (DEBUG > 0) {
            printf("Failed to configure MPU6050 interrupts\r\n");
        }
        return false;
    }

    if (!i2c_write_reg(MPU6050_ADDR, 0x38, 0x01)) { // INT_ENABLE: data ready
        if (DEBUG > 0) {
            printf("Failed to enable MPU6050 interrupts\r\n");
        }
        return false;
    }
    return true;
}

/**
 * @brief Initializes the ADS1115 analog-to-digital converter
 * @pre System is operating in a single core fashion, to prevent race conditions and resource conflicts
 * @return true if initialization was successful, false otherwise
 */
static bool robohand_init_ads1115(void) {
    if (!HAS_ADS1115) return true;  // Not an error if not enabled
    
    if (DEBUG > 0) {
        printf("Configuring ADS1115\r\n");
    }
    
    // Try to detect ADS1115 by reading its ID register
    // Note: ADS1115 doesn't have an ID register, so we'll check if writing
    // to the configuration register works
    uint16_t config = ADS1115_BASE_CONFIG | ADS1115_MUX_AIN0;
    uint8_t config_bytes[3] = {0x01, config >> 8, config & 0xFF};  // Reg 0x01 + config
    
    if (!i2c_write_with_retry(ADS1115_ADDR, config_bytes, 3, false, 100000)) {
        if (DEBUG > 0) {
            printf("ADS1115 not detected or not responding\r\n");
        }
        return false;
    }
    
    // Configure ALERT pin as input
    gpio_init(ADS1115_INT_PIN);
    gpio_set_dir(ADS1115_INT_PIN, GPIO_IN);
    gpio_pull_up(ADS1115_INT_PIN);
    
    if (DEBUG > 0) {
        printf("ADS1115 configuration successful\r\n");
    }
    
    return true;
}

/**
 * @brief Initializes the QMC5883L magnetometer
 * 
 * @return true if initialization was successful, false otherwise
 */
static bool robohand_init_qmc5883l(void) {
    if (HAS_QMC5883L) {
        if (DEBUG > 0) {
            printf("Configuring QMC5883L.\r\n");
        }
    
        uint8_t qmc_data[2];

        // Set the Set/Reset period (recommended by datasheet)
        qmc_data[0] = 0x0B;  // Register 0x0B: Set/Reset Period
        qmc_data[1] = 0x01;  // Value 0x01 as per datasheet recommendation
        i2c_write_with_retry(QMC5883L_ADDR, qmc_data, 2, false, 100000);

        // Configure for continuous mode, 50Hz ODR, 512 OSR, 2G range
        qmc_data[0] = 0x09;  // Register 0x09: Control Register 1
        qmc_data[1] = 0x0D;  // Mode=01 (continuous), ODR=01 (50Hz), OSR=00 (512), RNG=00 (2G)
        i2c_write_with_retry(QMC5883L_ADDR, qmc_data, 2, false, 100000);

        if (DEBUG > 0) {
            printf("QMC5883L configuration finished.\r\n");
        }
    }

    return true;
}

/**
 * @brief Initializes the BME280 environmental sensor
 */
static void robohand_init_bme280(void) {
    if (!HAS_BME280) return;
    
    if (DEBUG > 0) {
        printf("Configuring BME/BMP280...\r\n");
    }

    // Reset the device first
    uint8_t reset_cmd[2] = {0xE0, 0xB6}; // Reset register and command
    i2c_write_with_retry(BME280_ADDR, reset_cmd, 2, false, 100000);
    sleep_ms(10); // Wait for reset to complete
    
    // Check chip ID (should be 0x60 for BME280 or 0x58 for BMP280)
    uint8_t id_reg = 0xD0;
    uint8_t chip_id;
    i2c_write_with_retry(BME280_ADDR, &id_reg, 1, true, 100000);
    i2c_read_blocking(I2C_PORT, BME280_ADDR, &chip_id, 1, false);
    
    bool is_bmp280 = false;
    
    if (chip_id == 0x60) {
        if (DEBUG > 0) {
            printf("BME280 detected (Chip ID: 0x%02X)\r\n", chip_id);
        }
    } else if (chip_id == 0x58) {
        if (DEBUG > 0) {
            printf("BMP280 detected (Chip ID: 0x%02X) - humidity not available\r\n", chip_id);
        }
        is_bmp280 = true;
    } else {
        if (DEBUG > 0) {
            printf("BME/BMP280 not found! Chip ID: 0x%02X\r\n", chip_id);
        }
        return;
    }
    
    // Set humidity oversampling to x4 (only relevant for BME280)
    if (!is_bmp280) {
        uint8_t hum_config[2] = {0xF2, 0x03}; // Humidity control register, x4 oversampling
        i2c_write_with_retry(BME280_ADDR, hum_config, 2, false, 100000);
    }
    
    // Set temperature and pressure oversampling to x4, normal mode
    uint8_t meas_config[2] = {0xF4, 0x6F}; // T x4 (110), P x4 (110), Normal mode (11)
    i2c_write_with_retry(BME280_ADDR, meas_config, 2, false, 100000);
    
    // Set standby time to 500ms, filter coefficient to 8
    uint8_t config_reg[2] = {0xF5, 0x54}; // Standby 500ms (100), filter x8 (101)
    i2c_write_with_retry(BME280_ADDR, config_reg, 2, false, 100000);

    // Read and store calibration data
    read_bme280_calibration();
    
    if (DEBUG > 0) {
        printf("BME/BMP280 configuration complete\r\n");
    }
}

/*!
 * \file Robohand_interrupts.c
 * \brief Interrupt backend, for balance of power with complexity.
 * \details Still a work-in-progress.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#include "Robohand.h"
#include "Robohand_interrupts.h"
#include "Robohand_i2c.h"

#include <stdatomic.h>
#include <stdio.h>

/**
 * @brief Initialize interrupt-based sensor data acquisition
 */
void init_interrupts(void) {
    // Initialize a reference to at least one callback handler
    // The Pico SDK requires a GPIO callback reference
    static bool callback_initialized = false;
    
    if (HAS_ADS1115) {
        // Configure ALERT/RDY pin
        gpio_init(ADS1115_INT_PIN);
        gpio_set_dir(ADS1115_INT_PIN, GPIO_IN);
        gpio_pull_up(ADS1115_INT_PIN);
        
        if (!callback_initialized) {
            // First pin sets up the callback
            gpio_set_irq_enabled_with_callback(ADS1115_INT_PIN, GPIO_IRQ_EDGE_FALL, true, &ads1115_drdy_handler);
            callback_initialized = true;
        } else {
            // Additional pins just enable the interrupt
            gpio_set_irq_enabled(ADS1115_INT_PIN, GPIO_IRQ_EDGE_FALL, true);
        }

        // Start first conversion
        uint8_t channel = 0;
        uint16_t config = (uint16_t) (ADS1115_BASE_CONFIG | (0x4000 | (channel << 12)));
        uint8_t config_bytes[3] = {0x01, (uint8_t)(config >> 8), (uint8_t)(config & 0xFF)};
        i2c_write_with_retry(ADS1115_ADDR, config_bytes, 3, false, 2000);
    }

    if (HAS_BME280) {
        if (DEBUG > 0) {
            printf("Configuring BME280 interrupt.\r\n");
        }
        
        gpio_init(BME280_INT_PIN);
        gpio_set_dir(BME280_INT_PIN, GPIO_IN);
        gpio_pull_up(BME280_INT_PIN);
        
        if (!callback_initialized) {
            gpio_set_irq_enabled_with_callback(BME280_INT_PIN, GPIO_IRQ_EDGE_FALL, true, &bme280_drdy_handler);
            callback_initialized = true;
        } else {
            gpio_set_irq_enabled(BME280_INT_PIN, GPIO_IRQ_EDGE_FALL, true);
        }
    }

    if (HAS_MPU6050) {
        // Configure MPU6050 to generate interrupts
        uint8_t int_config[] = {0x37, 0x20}; // INT_PIN_CFG: INT active low, clear on read
        i2c_write_with_retry(MPU6050_ADDR, int_config, 2, false, 2000);
        
        uint8_t int_enable[] = {0x38, 0x01}; // INT_ENABLE: Enable data ready interrupt
        i2c_write_with_retry(MPU6050_ADDR, int_enable, 2, false, 2000);

        // Configure GPIO - note active LOW for MPU6050
        gpio_init(MPU6050_INT_PIN);
        gpio_set_dir(MPU6050_INT_PIN, GPIO_IN);
        gpio_pull_up(MPU6050_INT_PIN); // Pull-up since interrupt is active LOW
        
        if (!callback_initialized) {
            gpio_set_irq_enabled_with_callback(MPU6050_INT_PIN, GPIO_IRQ_LEVEL_LOW, true, &mpu6050_drdy_handler);
            callback_initialized = true;
        } else {
            gpio_set_irq_enabled(MPU6050_INT_PIN, GPIO_IRQ_LEVEL_LOW, true);
        }
                                           
        if (DEBUG > 0) {
            printf("MPU6050 interrupt enabled on pin %d.\r\n", MPU6050_INT_PIN);
        }
    }

    if (HAS_QMC5883L) {
        // Interrupt setup - Assuming pin will be held low when data ready
        gpio_init(QMC5883L_INT_PIN);
        gpio_set_dir(QMC5883L_INT_PIN, GPIO_IN);
        gpio_pull_up(QMC5883L_INT_PIN);
        
        if (!callback_initialized) {
            gpio_set_irq_enabled_with_callback(QMC5883L_INT_PIN, GPIO_IRQ_EDGE_FALL, true, &gy271_drdy_handler);
            callback_initialized = true;
        } else {
            gpio_set_irq_enabled(QMC5883L_INT_PIN, GPIO_IRQ_EDGE_FALL, true);
        }

        if (DEBUG > 0) {
            printf("QMC5883L interrupt enabled on pin %d.\r\n", QMC5883L_INT_PIN);
        }
    }
}

/**
 * @brief ADS1115 data ready interrupt handler
 * 
 * @param gpio GPIO pin number that triggered the interrupt
 * @param events Event type that triggered the interrupt
 */
static void ads1115_drdy_handler(uint gpio, uint32_t events) {
    if (gpio == ADS1115_INT_PIN && (events & GPIO_IRQ_EDGE_FALL)) {
        uint8_t old_flags = atomic_load(&i2c_operation_flags);
        uint8_t new_flags = old_flags | ADC_READ_FLAG;
        atomic_store(&i2c_operation_flags, new_flags);
    }
}

/**
 * @brief BME280 data ready interrupt handler
 * 
 * @param gpio GPIO pin number that triggered the interrupt
 * @param events Event type that triggered the interrupt
 */
static void bme280_drdy_handler(uint gpio, uint32_t events) {
    if (HAS_BME280) {
        // Some BME280 interrupts are active high, event should match initialization
        if (gpio == BME280_INT_PIN && (events & GPIO_IRQ_EDGE_FALL)) {
            uint8_t old_flags = atomic_load(&i2c_operation_flags);
            uint8_t new_flags = old_flags | BME_READ_FLAG;
            atomic_store(&i2c_operation_flags, new_flags);
        }
    }
}

/**
 * @brief QMC5883L data ready interrupt handler
 * 
 * @param gpio GPIO pin number that triggered the interrupt
 * @param events Event type that triggered the interrupt
 */
static void gy271_drdy_handler(uint gpio, uint32_t events) {
    if (HAS_QMC5883L) {
        // QMC5883L interrupts are active low, so check for EDGE_FALL
        if (gpio == QMC5883L_INT_PIN && (events & GPIO_IRQ_EDGE_FALL)) {
            uint8_t old_flags = atomic_load(&i2c_operation_flags);
            uint8_t new_flags = old_flags | QMC_READ_FLAG;
            atomic_store(&i2c_operation_flags, new_flags);
        }
    }
}

/**
 * @brief MPU6050 data ready interrupt handler
 * 
 * @param gpio GPIO pin number that triggered the interrupt
 * @param events Event type that triggered the interrupt
 */
static void mpu6050_drdy_handler(uint gpio, uint32_t events) {
    if (HAS_MPU6050) {
        // MPU6050 INT pin is active LOW, so check for LEVEL_LOW
        if (gpio == MPU6050_INT_PIN && (events & GPIO_IRQ_LEVEL_LOW)) {
            uint8_t old_flags = atomic_load(&i2c_operation_flags);
            uint8_t new_flags = old_flags | MPU_READ_FLAG;
            atomic_store(&i2c_operation_flags, new_flags);
        }
    }
}/*!
 * \file Robohand_reader.c
 * \brief Contains reader functions for sensor access.
 * \details Reader functions are called via the chosen backend.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#include "Robohand.h"
#include "Robohand_i2c.h"
#include "Robohand_reader.h"
#include "Robohand_struct.h"

#include "hardware/i2c.h"

#include <math.h>
#include <stdio.h>

/**
 * @brief Convert raw ADS1115 value to voltage
 * 
 * @param raw 16-bit raw ADC value
 * @return Voltage in volts
 */
float ads_voltage(uint16_t raw) {
    return (int16_t)raw * (4.096f / 32768.0f); // ±4.096V range
}

/**
 * @brief Read specified channel from ADS1115 ADC
 * 
 * @param channel ADC channel to read (0-3)
 * @return Raw 16-bit ADC value
 */
uint16_t read_ads_channel(int channel) {
    uint16_t config = (uint16_t) (ADS1115_BASE_CONFIG | (0x4000 | (channel << 12))); // Set MUX
    uint8_t config_bytes[2] = {config >> 8, config & 0xFF};
    i2c_write_with_retry(ADS1115_ADDR, config_bytes, 2, true, 4000);
    sleep_ms(8); // Wait for conversion
    uint8_t reg = 0x00; // Conversion register
    i2c_write_with_retry(ADS1115_ADDR, &reg, 1, true, 4000);
    uint8_t buffer[2];
    i2c_read_blocking(I2C_PORT, ADS1115_ADDR, buffer, 2, false);
    return (uint16_t)(buffer[0] << 8) | buffer[1];
}

/**
 * @brief Read data from all configured ADC channels
 */
/**
 * @brief Read calibration data from the BME280 sensor
 */
void read_bme280_calibration(void) {
    uint8_t calib_data[32];  // Total calibration data (24+8)
    uint8_t chip_id = 0;
    bool is_bmp280 = false;
    
    // Check which sensor we have
    uint8_t id_reg = 0xD0;
    if (mutex_enter_timeout_ms(&i2c_mutex, 50)) {
        i2c_write_with_retry(BME280_ADDR, &id_reg, 1, true, 5000);
        i2c_read_blocking(I2C_PORT, BME280_ADDR, &chip_id, 1, false);
        mutex_exit(&i2c_mutex);
    }
    
    is_bmp280 = (chip_id == 0x58);
    
    // Read temperature and pressure calibration (reg 0x88-0xA1)
    uint8_t reg = 0x88;
    bool success = false;
    
    if (mutex_enter_timeout_ms(&i2c_mutex, 50)) {
        i2c_write_with_retry(BME280_ADDR, &reg, 1, true, 100000);
        success = (i2c_read_blocking(I2C_PORT, BME280_ADDR, calib_data, 24, false) == 24);
        mutex_exit(&i2c_mutex);
    }
    
    if (!success) {
        if (DEBUG > 0) {
            printf("Failed to read BME/BMP280 calibration data (T/P)\r\n");
        }
        return;
    }
    
    // For BME280, read humidity calibration (reg 0xE1-0xE7)
    if (!is_bmp280) {
        reg = 0xE1;
        success = false;
        
        if (mutex_enter_timeout_ms(&i2c_mutex, 50)) {
            i2c_write_with_retry(BME280_ADDR, &reg, 1, true, 100000);
            success = (i2c_read_blocking(I2C_PORT, BME280_ADDR, calib_data + 24, 8, false) == 8);
            mutex_exit(&i2c_mutex);
        }
        
        if (!success && if DEBUG > 0) {
                printf("Failed to read BME280 calibration data (H)\r\n");
            }
            // Continue anyway - we can still read temperature and pressure
        }
    }
    
    // Parse temperature calibration
    bme280_calib.dig_T1 = (uint16_t)((calib_data[1] << 8) | calib_data[0]);
    bme280_calib.dig_T2 = (int16_t)((calib_data[3] << 8) | calib_data[2]);
    bme280_calib.dig_T3 = (int16_t)((calib_data[5] << 8) | calib_data[4]);
    
    // Parse pressure calibration
    bme280_calib.dig_P1 = (uint16_t)((calib_data[7] << 8) | calib_data[6]);
    bme280_calib.dig_P2 = (int16_t)((calib_data[9] << 8) | calib_data[8]);
    bme280_calib.dig_P3 = (int16_t)((calib_data[11] << 8) | calib_data[10]);
    bme280_calib.dig_P4 = (int16_t)((calib_data[13] << 8) | calib_data[12]);
    bme280_calib.dig_P5 = (int16_t)((calib_data[15] << 8) | calib_data[14]);
    bme280_calib.dig_P6 = (int16_t)((calib_data[17] << 8) | calib_data[16]);
    bme280_calib.dig_P7 = (int16_t)((calib_data[19] << 8) | calib_data[18]);
    bme280_calib.dig_P8 = (int16_t)((calib_data[21] << 8) | calib_data[20]);
    bme280_calib.dig_P9 = (int16_t)((calib_data[23] << 8) | calib_data[22]);
    
    // Parse humidity calibration (only for BME280)
    if (!is_bmp280) {
        bme280_calib.dig_H1 = calib_data[24];
        bme280_calib.dig_H2 = (int16_t)((calib_data[26] << 8) | calib_data[25]);
        bme280_calib.dig_H3 = calib_data[27];
        
        // These are packed differently
        bme280_calib.dig_H4 = (int16_t)((calib_data[28] << 4) | (calib_data[29] & 0x0F));
        bme280_calib.dig_H5 = (int16_t)((calib_data[30] << 4) | (calib_data[29] >> 4));
        bme280_calib.dig_H6 = (int8_t)calib_data[31];
    } else {
        // Set humidity calibration data to 0 for BMP280
        bme280_calib.dig_H1 = 0;
        bme280_calib.dig_H2 = 0;
        bme280_calib.dig_H3 = 0;
        bme280_calib.dig_H4 = 0;
        bme280_calib.dig_H5 = 0;
        bme280_calib.dig_H6 = 0;
    }
    
    if (DEBUG > 0) {
        printf("BME/BMP280 calibration data read successfully\r\n");
        printf("T1=%u, T2=%d, T3=%d\r\n", bme280_calib.dig_T1, bme280_calib.dig_T2, bme280_calib.dig_T3);
        printf("P1=%u, P2=%d, P3=%d\r\n", bme280_calib.dig_P1, bme280_calib.dig_P2, bme280_calib.dig_P3);
        if (!is_bmp280) {
            printf("H1=%u, H2=%d, H3=%u, H4=%d, H5=%d, H6=%d\r\n", 
                  bme280_calib.dig_H1, bme280_calib.dig_H2, bme280_calib.dig_H3,
                  bme280_calib.dig_H4, bme280_calib.dig_H5, bme280_calib.dig_H6);
        }
    }
}

/**
 * @brief Compensate BME280 raw data to get temperature, pressure, and humidity
 * 
 * @param raw_data Raw data from sensor (8 bytes)
 * @param temperature Pointer to store compensated temperature (in °C)
 * @param pressure Pointer to store compensated pressure (in Pa)
 * @param humidity Pointer to store compensated humidity (in %RH)
 * @param altitude Pointer to store calculated altitude (in m)
 * @note Based on default compensation code from datasheet
 */

bool read_bme280_data(void) {
    if (!HAS_BME280) return false;
    
    uint8_t raw_data[8]; // Pressure (3), Temperature (3), Humidity (2)
    bool success = false;
    
    if (mutex_enter_timeout_ms(&i2c_mutex, 50)) {
        // Read raw data from registers 0xF7-0xFE
        uint8_t reg = 0xF7;
        
        if (i2c_write_with_retry(BME280_ADDR, &reg, 1, true, 100000) &&
            i2c_read_blocking(I2C_PORT, BME280_ADDR, raw_data, 8, false) == 8) {
            
            float temperature = 0.0f;
            float pressure = 0.0f;
            float humidity = 0.0f;
            float altitude = 0.0f;
                
            // Convert raw data to physical values
            compensate_bme280_data(raw_data, &temperature, &pressure, &humidity, &altitude);
                
            // Store values in the sensor_readings structure
            if (mutex_enter_timeout_ms(&sensor_readings.data_mutex, 50)) {
                sensor_readings.pressure = pressure;
                sensor_readings.temperature = temperature;
                sensor_readings.humidity = humidity;
                sensor_readings.altitude = altitude;
                    
                mutex_exit(&sensor_readings.data_mutex);
                success = true;
            }
        }
        
        mutex_exit(&i2c_mutex);
    }
    
    return success;
}

/**
 * @brief Read data from the QMC5883L magnetometer
 * 
 * @return true if read was successful, false otherwise
 */
bool read_qmc5883l_data(void) {
    if (!HAS_QMC5883L) return false;
    
    bool success = false;
    uint8_t buffer[6];
    uint8_t status_reg = 0x06; // Status register
    uint8_t status;
    
    if (mutex_enter_timeout_ms(&i2c_mutex, 50)) {
        // Check if data is ready
        i2c_write_with_retry(QMC5883L_ADDR, &status_reg, 1, true, 100000);
        if (i2c_read_blocking(I2C_PORT, QMC5883L_ADDR, &status, 1, false) == 1 && status & 0x01) { // Data ready bit (DRDY)
            // Read data registers (0x00-0x05)
            uint8_t data_reg = 0x00;
            i2c_write_with_retry(QMC5883L_ADDR, &data_reg, 1, true, 100000);
            if (i2c_read_blocking(I2C_PORT, QMC5883L_ADDR, buffer, 6, false) == 6 && mutex_enter_timeout_ms(&sensor_readings.data_mutex, 50)) {
                    // Data is in X, Y, Z order, each axis is 16-bit little-endian
                    sensor_readings.mag[0] = (int16_t)(buffer[0] | (buffer[1] << 8));
                    sensor_readings.mag[1] = (int16_t)(buffer[2] | (buffer[3] << 8));
                    sensor_readings.mag[2] = (int16_t)(buffer[4] | (buffer[5] << 8));
                    mutex_exit(&sensor_readings.data_mutex);
                    success = true;
            }
        }
        mutex_exit(&i2c_mutex);
    }
    
    return success;
}

/**
 * @brief Read data from the MPU6050 accelerometer and gyroscope
 * 
 * @return true if read was successful, false otherwise
 */
bool read_mpu6050_data(void) {
    if (!HAS_MPU6050) return false;
    
    uint8_t buffer[14] = {0};  // Initialize to prevent use of uninitialized values
    bool success = false;
    
    if (!mutex_try_enter(&i2c_mutex, NULL)) {
        return false;
    }
    
    // Read all data at once from registers 0x3B to 0x48
    // ACCEL_XOUT_H (0x3B) through GYRO_ZOUT_L (0x48)
    uint8_t reg = MPU6050_ACCEL_XOUT_H;
    if (i2c_write_with_retry(MPU6050_ADDR, &reg, 1, true, 5000) &&
        i2c_read_with_retry(MPU6050_ADDR, buffer, 14, false, 5000)) {
        success = true;
    }
    
    // Clear interrupt flag
    uint8_t int_status_reg = 0x3A;
    uint8_t int_status;
    i2c_write_with_retry(MPU6050_ADDR, &int_status_reg, 1, true, 5000);
    i2c_read_with_retry(MPU6050_ADDR, &int_status, 1, false, 5000);
    
    mutex_exit(&i2c_mutex);
    
    // Process data if read was successful
    if (success && mutex_enter_timeout_ms(&sensor_readings.data_mutex, 50)) {
        // Convert and store accelerometer data (signed 16-bit values)
        sensor_readings.accel[0] = (int16_t)((buffer[0] << 8) | buffer[1]);
        sensor_readings.accel[1] = (int16_t)((buffer[2] << 8) | buffer[3]);
        sensor_readings.accel[2] = (int16_t)((buffer[4] << 8) | buffer[5]);
        
        // Convert and store gyroscope data (signed 16-bit values)
        sensor_readings.gyro[0] = (int16_t)((buffer[8] << 8) | buffer[9]);
        sensor_readings.gyro[1] = (int16_t)((buffer[10] << 8) | buffer[11]);
        sensor_readings.gyro[2] = (int16_t)((buffer[12] << 8) | buffer[13]);
        
        // Print raw values to debug
        if (DEBUG > 1) {
            printf("MPU6050 raw: ax=%d, ay=%d, az=%d, gx=%d, gy=%d, gz=%d\r\n",
                  sensor_readings.accel[0], sensor_readings.accel[1], sensor_readings.accel[2],
                  sensor_readings.gyro[0], sensor_readings.gyro[1], sensor_readings.gyro[2]);
        }
        
        mutex_exit(&sensor_readings.data_mutex);
        return true;
    }
    
    if (DEBUG > 0 && !success) {
        printf("Failed to read MPU6050 data\r\n");
    }
    
    return false;
}

void compensate_bme280_data(const uint8_t *raw_data, float *temperature, float *pressure, float *humidity, float *altitude) {
    // Parse raw values (20-bit values shifted into 32-bit integers)
    int32_t raw_temp = (raw_data[3] << 12) | (raw_data[4] << 4) | (raw_data[5] >> 4);
    int32_t raw_press = (raw_data[0] << 12) | (raw_data[1] << 4) | (raw_data[2] >> 4);
    int32_t raw_hum = (raw_data[6] << 8) | raw_data[7];
    
    // Temperature calculation (returns temperature in DegC)
    int32_t var1;
    int32_t var2;
    int32_t t_fine;
    var1 = (((raw_temp >> 3) - ((int32_t)bme280_calib.dig_T1 << 1)) * ((int32_t)bme280_calib.dig_T2)) >> 11;
    var2 = (((((raw_temp >> 4) - ((int32_t)bme280_calib.dig_T1)) * ((raw_temp >> 4) - ((int32_t)bme280_calib.dig_T1))) >> 12) * ((int32_t)bme280_calib.dig_T3)) >> 14;
    t_fine = var1 + var2;
    *temperature = ((t_fine * 5 + 128) >> 8) / 100.0f;
    
    // Pressure calculation (returns pressure in Pa)
    int64_t p_var1;
    int64_t p_var2;
    int64_t p;

    p_var1 = ((int64_t)t_fine) - 128000;
    p_var2 = p_var1 * p_var1 * (int64_t)bme280_calib.dig_P6;
    p_var2 = p_var2 + ((p_var1 * (int64_t)bme280_calib.dig_P5) << 17);
    p_var2 = p_var2 + (((int64_t)bme280_calib.dig_P4) << 35);
    p_var1 = ((p_var1 * p_var1 * (int64_t)bme280_calib.dig_P3) >> 8) + ((p_var1 * (int64_t)bme280_calib.dig_P2) << 12);
    p_var1 = ((((int64_t)1) << 47) + p_var1) * ((int64_t)bme280_calib.dig_P1) >> 33;
    
    if (p_var1 == 0) {
        *pressure = 0; // Avoid division by zero
    } else {
        p = 1048576 - raw_press;
        p = (((p << 31) - p_var2) * 3125) / p_var1;
        p_var1 = (((int64_t)bme280_calib.dig_P9) * (p >> 13) * (p >> 13)) >> 25;
        p_var2 = (((int64_t)bme280_calib.dig_P8) * p) >> 19;
        p = ((p + p_var1 + p_var2) >> 8) + (((int64_t)bme280_calib.dig_P7) << 4);
        *pressure = (float) p / 256.0f; // Convert to Pa
    }
    
    // Check chip ID to determine if we have a BME280 or BMP280
    uint8_t id_reg = 0xD0;
    uint8_t chip_id = 0;
    
    // Try to read chip ID only if mutex is available
    bool id_read_success = false;
    if (mutex_try_enter(&i2c_mutex, NULL)) {
        i2c_write_with_retry(BME280_ADDR, &id_reg, 1, true, 5000);
        if (i2c_read_with_retry(BME280_ADDR, &chip_id, 1, false, 5000)) {
            id_read_success = true;
        }
        mutex_exit(&i2c_mutex);
    }
    
    // For BMP280 (0x58), set humidity to 0 since it doesn't have humidity sensor
    if (!id_read_success || chip_id == 0x58) {
        *humidity = 0.0f;
    } else {
        // Humidity Calculation for BME280
        int32_t v_x1_u32r;
        v_x1_u32r = (t_fine - ((int32_t)76800));
        v_x1_u32r = (((((raw_hum << 14) - (((int32_t)bme280_calib.dig_H4) << 20) - (((int32_t)bme280_calib.dig_H5) * v_x1_u32r)) +
                     ((int32_t)16384)) >> 15) * (((((((v_x1_u32r * ((int32_t)bme280_calib.dig_H6)) >> 10) * (((v_x1_u32r *
                     ((int32_t)bme280_calib.dig_H3)) >> 11) + ((int32_t)32768))) >> 10) + ((int32_t)2097152)) *
                     ((int32_t)bme280_calib.dig_H2) + 8192) >> 14));
        
        v_x1_u32r = (v_x1_u32r - (((((v_x1_u32r >> 15) * (v_x1_u32r >> 15)) >> 7) * ((int32_t)bme280_calib.dig_H1)) >> 4));
        v_x1_u32r = (v_x1_u32r < 0 ? 0 : v_x1_u32r);
        v_x1_u32r = (v_x1_u32r > 419430400 ? 419430400 : v_x1_u32r);
        
        *humidity = (float)(v_x1_u32r >> 12) / 1024.0f;
        
        // Constrain humidity to valid range
        if (*humidity > 100.0f) *humidity = 100.0f;
        if (*humidity < 0.0f) *humidity = 0.0f;
    }
    
    // Calculate altitude using the international barometric formula
    // Sea level pressure is 101325 Pa
    if (*pressure > 0) {
        *altitude = 44330.0f * (1.0f - powf((*pressure / 101325.0f), 0.1903f));
    } else {
        *altitude = 0.0f;
    }
    
    if (DEBUG > 1) {
        printf("Raw: T=%ld, P=%ld\r\n", raw_temp, raw_press);
        printf("Calculated: T=%.2f°C, P=%.2fPa, Alt=%.2fm\r\n", 
              *temperature, *pressure, *altitude);
    }
}#include "Robohand_rgb.h"
#include "Robohand_struct.h"

#include <math.h>
#include <stdio.h>

#include "hardware/gpio.h"
#include "hardware/pwm.h"

#include "pico/mutex.h"

//Gamma correction table (gamma = 2.8) for brightness smoothing
const uint8_t gamma_table[256] = {
    0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,   0,
    1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   1,   2,   2,   2,   2,
    2,   2,   2,   3,   3,   3,   3,   3,   4,   4,   4,   4,   5,   5,   5,   5,
    6,   6,   6,   7,   7,   7,   8,   8,   8,   9,   9,   9,   10,  10,  11,  11,
    12,  12,  13,  13,  14,  14,  15,  15,  16,  16,  17,  17,  18,  18,  19,  20,
    20,  21,  22,  22,  23,  24,  24,  25,  26,  27,  27,  28,  29,  30,  31,  31,
    32,  33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
    49,  50,  51,  52,  53,  55,  56,  57,  59,  60,  61,  63,  64,  65,  67,  68,
    70,  71,  73,  74,  76,  78,  79,  81,  83,  84,  86,  88,  90,  91,  93,  95,
    97,  99,  101, 103, 105, 107, 109, 111, 113, 115, 117, 120, 122, 124, 126, 129,
    131, 134, 136, 138, 141, 143, 146, 148, 151, 154, 156, 159, 162, 165, 167, 170,
    173, 176, 179, 182, 185, 188, 191, 194, 197, 200, 204, 207, 210, 213, 217, 220,
    224, 227, 231, 234, 238, 241, 245, 249, 252, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
    255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255
};
static struct repeating_timer blink_timer;                          ///< Timer for triggering the blink callback

static bool blink_callback(struct repeating_timer *t);

/** @defgroup rgb_control_impl RGB LED Control Implementation
 *  @brief Implementation of RGB LED control functions.
 *  @{
 */

/*!
 * @brief Initializes the RGB LED subsystem.
 * @details Configures PWM hardware and initializes mutexes.
 */
void init_rgb(void) {
    if (HAS_RGB) {
        if (DEBUG > 0) {
            printf("Initializing common cathode RGB LED on pins R:%d G:%d B:%d\r\n", 
                  RGB_RED_PIN, RGB_GREEN_PIN, RGB_BLUE_PIN);
        }
        
        // Initialize pins
        gpio_init(RGB_RED_PIN);
        gpio_init(RGB_GREEN_PIN);
        gpio_init(RGB_BLUE_PIN);
        
        // Set to output mode
        gpio_set_dir(RGB_RED_PIN, GPIO_OUT);
        gpio_set_dir(RGB_GREEN_PIN, GPIO_OUT);
        gpio_set_dir(RGB_BLUE_PIN, GPIO_OUT);
        
        // Initialize PWM
        gpio_set_function(RGB_RED_PIN, GPIO_FUNC_PWM);
        gpio_set_function(RGB_GREEN_PIN, GPIO_FUNC_PWM);
        gpio_set_function(RGB_BLUE_PIN, GPIO_FUNC_PWM);

        // Initialize RGB structure with specific settings
        init_rgb_state_struct(&rgb_conf);
        
        // Override the pwm_wrap with a smaller value for better resolution
        rgb_conf.pwm_wrap = 255;
        
        // Configure PWM with 8-bit resolution
        pwm_config config = pwm_get_default_config();
        pwm_config_set_wrap(&config, rgb_conf.pwm_wrap);
        // Use a small clock divider for brighter output
        pwm_config_set_clkdiv(&config, 1.0f);
        
        // Get the slices for each pin
        uint slices[] = {
            pwm_gpio_to_slice_num(RGB_RED_PIN),
            pwm_gpio_to_slice_num(RGB_GREEN_PIN),
            pwm_gpio_to_slice_num(RGB_BLUE_PIN)
        };
        
        // Initialize the PWM pins
        for(int i = 0; i < 3; i++) {
            pwm_init(slices[i], &config, true);
        }
        
        // Set maximum brightness
        rgb_conf.current_brightness = 1.0f;
        
        // Turn the LED on with test colors at full brightness
        rgb_set_color(255, 0, 0);  // Full red
        
        if (DEBUG > 0) {
            printf("RGB LED initialization complete\r\n");
        }
    }
}
 
/*!
 * @brief Sets the RGB LED color.
 * @param[in] r Red component (0-255).
 * @param[in] g Green component (0-255).
 * @param[in] b Blue component (0-255).
 */
void rgb_set_color(uint8_t r, uint8_t g, uint8_t b) {
    if (HAS_RGB) {
        if (DEBUG > 0) {
            printf("Setting RGB color to (%d, %d, %d)\r\n", r, g, b);
        }
        
        mutex_enter_blocking(&rgb_conf.rgb_mutex);
        // Store original values
        rgb_conf.current_r = r;
        rgb_conf.current_g = g;
        rgb_conf.current_b = b;
        
        // Skip gamma correction temporarily for testing
        // Just apply brightness
        uint16_t red = (uint16_t)(r * rgb_conf.current_brightness);
        uint16_t green = (uint16_t)(g * rgb_conf.current_brightness);
        uint16_t blue = (uint16_t)(b * rgb_conf.current_brightness);
        mutex_exit(&rgb_conf.rgb_mutex);
        
        // Set PWM levels directly
        mutex_enter_blocking(&rgb_conf.pwm_mutex);
        pwm_set_gpio_level(RGB_RED_PIN, red);
        pwm_set_gpio_level(RGB_GREEN_PIN, green);
        pwm_set_gpio_level(RGB_BLUE_PIN, blue);
        mutex_exit(&rgb_conf.pwm_mutex);
        
        if (DEBUG > 0) {
            printf("PWM levels set to R:%d G:%d B:%d\r\n", red, green, blue);
        }
    }
}

/*!
 * @brief Sets the brightness of RGB LED.
 * @param brightness Brightness level (0.0-1.0).
 */
void rgb_set_brightness(float brightness) {
    if (HAS_RGB) {
        mutex_enter_blocking(&rgb_conf.rgb_mutex);

        rgb_conf.current_brightness = fmaxf(0.0f, fminf(1.0f, brightness));

        // Apply brightness and gamma correction
        uint16_t red = gamma_table[(uint8_t)(rgb_conf.current_r * rgb_conf.current_brightness)];
        uint16_t green = gamma_table[(uint8_t)(rgb_conf.current_g * rgb_conf.current_brightness)];
        uint16_t blue = gamma_table[(uint8_t)(rgb_conf.current_b * rgb_conf.current_brightness)];

        mutex_exit(&rgb_conf.rgb_mutex);

        // Set PWM levels
        mutex_enter_blocking(&rgb_conf.pwm_mutex);
        pwm_set_gpio_level(RGB_RED_PIN, red);
        pwm_set_gpio_level(RGB_GREEN_PIN, green);
        pwm_set_gpio_level(RGB_BLUE_PIN, blue);
        mutex_exit(&rgb_conf.pwm_mutex);
    }
}

/*!
 * @brief Configures the RGB to blink at a specified interval.
 * @param enable Enable or disable blinking.
 * @param interval_ms Blink interval in milliseconds.
 */
void rgb_blink(bool enable, uint32_t interval_ms) {
    if (!HAS_RGB) return;
    
    mutex_enter_blocking(&rgb_conf.rgb_mutex);
    
    // If we're changing state, safely handle the timer
    if (rgb_conf.blink_active != enable) {
        if (rgb_conf.blink_active) {
            // Stop the timer first
            bool timer_cancelled = cancel_repeating_timer(&blink_timer);
            if (!timer_cancelled && DEBUG > 0) {
                printf("Warning: Failed to cancel blink timer\r\n");
            }
            rgb_conf.blink_active = false;
            
            // Restore color when disabling
            rgb_set_color(rgb_conf.current_r, rgb_conf.current_g, rgb_conf.current_b);
        }
        
        // Starting a new timer
        if (enable) {
            rgb_conf.blink_interval = interval_ms;
            rgb_conf.blink_state = true; // Start in the ON state
            rgb_conf.blink_active = add_repeating_timer_ms(
                -(int32_t)interval_ms, 
                &blink_callback, 
                NULL, 
                &blink_timer
            );
            
            if (!rgb_conf.blink_active && DEBUG > 0) {
                printf("Error: Failed to start blink timer\r\n");
            }
        }
    } 
    // Just updating the interval of an active timer
    else if (enable && rgb_conf.blink_interval != interval_ms) {
        cancel_repeating_timer(&blink_timer);
        rgb_conf.blink_interval = interval_ms;
        rgb_conf.blink_active = add_repeating_timer_ms(
            -(int32_t)interval_ms, 
            &blink_callback, 
            NULL, 
            &blink_timer
        );
    }
    
    mutex_exit(&rgb_conf.rgb_mutex);
}

/*!
 * @brief Callback allowing for toggling of RGB functionality.
 * @param t Pointer to the repeating timer structure.
 * @return Always returns true to continue the timer.
 */
static bool blink_callback(struct repeating_timer *t) {
    (void)t;

    if (HAS_RGB && mutex_try_enter(&rgb_conf.rgb_mutex, NULL) && rgb_conf.blink_active) {
        rgb_conf.blink_state = !rgb_conf.blink_state;
                
        if(rgb_conf.blink_state) {
            // Restore original color
            pwm_set_gpio_level(RGB_RED_PIN, gamma_table[(uint8_t)(rgb_conf.current_r * rgb_conf.current_brightness)]);
            pwm_set_gpio_level(RGB_GREEN_PIN, gamma_table[(uint8_t)(rgb_conf.current_g * rgb_conf.current_brightness)]);
            pwm_set_gpio_level(RGB_BLUE_PIN, gamma_table[(uint8_t)(rgb_conf.current_b * rgb_conf.current_brightness)]);
        }
            
        else {
            // Turn off LEDs
            pwm_set_gpio_level(RGB_RED_PIN, 0);
            pwm_set_gpio_level(RGB_GREEN_PIN, 0);
            pwm_set_gpio_level(RGB_BLUE_PIN, 0);
        }

        mutex_exit(&rgb_conf.rgb_mutex);
    }
    
    return true;
}

/** @} */ // end of rgb_control_impl#include "Robohand.h"
#include "Robohand_struct.h"
#include "Robohand_servos.h"

#include <stdio.h>
#include <string.h>

#include "pico/multicore.h"
#include "hardware/pwm.h"
#include "hardware/gpio.h"

// Dedicated hardware mutexes
mutex_t servo_mutex;                                         ///< Mutex protecting Servo access
const uint SERVO_PINS[NUM_SERVOS] = {11, 12, 13, 14, 15};           ///< GPIO pins to use for mechanical actuation
static const float PWM_US_TO_LEVEL = (39062.0f / 20000.0f);         ///< Constant value used for PWM conversion for servos
static absolute_time_t prev_update_time;                            ///< Used to track the time since last update

static void update_servo_position(int servo_index, uint32_t elapsed, uint32_t duration_us);

 /** @defgroup servo_control_impl Servo Control Implementation
  *  @brief Implementation of servo control functions.
  *  @{
  */
 
 /*!
  * @brief Actuates a servo to a specified position over a given duration.
  * @param servo Servo index (0 to NUM_SERVOS-1).
  * @param pulse_width Target pulse width in microseconds (500-2500µs).
  * @param duration_ms Movement duration in milliseconds.
  */
 void actuate_servo(uint8_t servo, uint16_t pulse_width, uint16_t duration_ms) {
    if (!HAS_SERVOS) return;
    
    if (servo >= NUM_SERVOS) {
        if (DEBUG > 0) {
            printf("Error: Invalid servo index %d\r\n", servo);
        }
        return;
    }
    
    // Validate inputs with proper bounds
    pulse_width = constrain_u16(pulse_width, SERVO_MIN_PULSE, SERVO_MAX_PULSE);
    duration_ms = constrain_u16(duration_ms, 100, MAX_MOVE_DURATION_MS); // Enforce minimum duration
    
    // Pack command - ensure bit shifting is correct
    uint32_t command = ((uint32_t)servo << 28) | 
                      ((uint32_t)(pulse_width & 0xFFF) << 16) | 
                       (uint32_t)(duration_ms & 0xFFFF);
    
    // Send command to other core
    multicore_fifo_push_blocking(command);
}
 /*!
  * @brief Retrieves the current status of a servo.
  * @param[in] servo Servo index (0 to NUM_SERVOS-1).
  * @param[out] dest Pointer to servo_motion_profile to populate.
  * @return True if successfully acquired, false if error.
  * @note An error in this case could simply be that the mutexes could not be acquired
  */
 bool get_servo_status(uint8_t servo, servo_motion_profile* dest) {
    if (HAS_SERVOS) {
        if(servo >= NUM_SERVOS) {
            return false;
        }

        // If user hasn't allocated the array, do it
        if (dest == NULL) {
            init_servo_motion_profile_struct(dest, 0);
        }

        if(!mutex_enter_timeout_ms(&servo_profiles[servo].profile_mutex, 25)) { // 25ms
            memcpy(dest, &servo_profiles[servo], sizeof(servo_motion_profile));
            mutex_exit(&servo_profiles[servo].profile_mutex);
            return true;
        }
    }

    return false;
}

/*!
 * @brief Initializes PWM for servo control.
 * @details Configures PWM frequency to 50Hz (20ms period) for standard servos.
 * @post All servo pins are configured with correct PWM settings.
 */
void init_servo_pwm(void) {
    if (HAS_SERVOS) {
        for(int i = 0; i < NUM_SERVOS; i++) {
            gpio_set_function(SERVO_PINS[i], GPIO_FUNC_PWM);
            uint slice_num = pwm_gpio_to_slice_num(SERVO_PINS[i]);
            pwm_config config = pwm_get_default_config();
            pwm_config_set_clkdiv(&config, 64.0f);  // 125MHz / 64 = 1.953125MHz
            pwm_config_set_wrap(&config, 39062);    // 1.953125MHz / 39062 ≈ 50Hz
            pwm_init(slice_num, &config, true);
        }
    }
}

/*!
 * @brief Function that unpacks commands sent from other modules.
 * @details Reads from the FIFO and parses servo commands.
 * @param cmd The FIFO command to process.
 * @post The appropriate servo profile is updated.
 */
void handle_servo_commands(uint32_t cmd) {
    if (!HAS_SERVOS) return;
    
    // Command format: [4-bit servo index][12-bit pulse width][16-bit duration]
    uint8_t servo = (cmd >> 28) & 0x0F;         // Extract servo index (top 4 bits)
    uint16_t pulse_width = (cmd >> 16) & 0xFFF; // Extract pulse width (next 12 bits)
    uint16_t duration = cmd & 0xFFFF;           // Extract duration (lower 16 bits)
    
    // Validate servo index
    if (servo >= NUM_SERVOS) {
        if (DEBUG > 0) {
            printf("Error: Invalid servo index %d\r\n", servo);
        }
        return;
    }
    
    // Constrain pulse width and duration to valid ranges
    pulse_width = constrain_u16(pulse_width, SERVO_MIN_PULSE, SERVO_MAX_PULSE);
    duration = constrain_u16(duration, 100, MAX_MOVE_DURATION_MS);
    
    // Try to update the servo profile with a timeout
    if (mutex_enter_timeout_ms(&servo_profiles[servo].profile_mutex, 50)) {
        servo_profiles[servo].target_pw = pulse_width;
        servo_profiles[servo].duration_ms = duration;
        servo_profiles[servo].start_time = time_us_32();
        servo_profiles[servo].is_moving = true;
        mutex_exit(&servo_profiles[servo].profile_mutex);
        
        if (DEBUG > 1) {
            printf("Servo %d command: pw=%d, dur=%d\r\n", servo, pulse_width, duration);
        }
    } else if (DEBUG > 0) {
        printf("Error: Failed to acquire servo %d mutex\r\n", servo);
    }
}

/*!
 * @brief Update servo positions using motion profiles.
 * @details Calculates smooth transitions between current and target positions.
 * @post Servo PWM outputs are updated with new calculated positions.
 */
void update_servo_positions(void) {
    if (!HAS_SERVOS) return;
    
    absolute_time_t now = get_absolute_time();
    uint64_t dt_us = absolute_time_diff_us(prev_update_time, now);
    
    if (dt_us <= 0) {
        return;  // Prevent time travel or division by zero
    }
    
    prev_update_time = now;
    
    for (int i = 0; i < NUM_SERVOS; i++) {
        // Try to get mutex for this servo
        if (!mutex_try_enter(&servo_mutex, NULL)) {
            continue;  // Skip this servo if we can't get the mutex
        }
        
        // Skip non-moving servos
        if (!servo_profiles[i].is_moving) {
            mutex_exit(&servo_mutex);
            continue;
        }

        // Calculate movement progress
        uint32_t elapsed = time_us_32() - servo_profiles[i].start_time;
        uint32_t duration_us = servo_profiles[i].duration_ms * 1000;
        
        // Check if movement is complete
        if (elapsed >= duration_us) {
            // Movement complete, set final position
            servo_profiles[i].current_pw = servo_profiles[i].target_pw;
            servo_profiles[i].is_moving = false;
        } else {
            // Movement in progress, calculate new position
            update_servo_position(i, elapsed, duration_us);
        }

        // Update PWM (50Hz = 20ms period)
        uint16_t level = (uint16_t)(((float)servo_profiles[i].current_pw) * PWM_US_TO_LEVEL);
        pwm_set_gpio_level(SERVO_PINS[i], level);
        
        // Release the mutex
        mutex_exit(&servo_mutex);
    }
}

/*!
 * @brief Updates a single servo position.
 * @param servo_index The index of the servo to update.
 * @param elapsed Elapsed time in microseconds since movement started.
 * @param duration_us Total movement duration in microseconds.
 */
static void update_servo_position(int servo_index, uint32_t elapsed, uint32_t duration_us) {
    // Calculate progress as a float between 0.0 and 1.0
    float progress = (float)elapsed / (float)duration_us;
    
    // Apply S-curve for smooth acceleration and deceleration
    float eased_progress;
    
    if (progress < 0.5f) {
        // First half - accelerate
        eased_progress = 2.0f * progress * progress;
    } else {
        // Second half - decelerate
        float p = progress - 1.0f;
        eased_progress = 1.0f - 2.0f * p * p;
    }
    
    // Calculate new position
    int32_t delta = servo_profiles[servo_index].target_pw - 
                   servo_profiles[servo_index].current_pw;
                  
    uint16_t new_pw = servo_profiles[servo_index].current_pw + 
                     (uint16_t)((float)delta * eased_progress);
                     
    // Constrain within valid range
    servo_profiles[servo_index].current_pw = constrain_u16(new_pw, 
                                 SERVO_MIN_PULSE, 
                                 SERVO_MAX_PULSE);
}

/** @} */ // end of servo_control_impl

#include <math.h>
#include <stdio.h>
#include <string.h>

#include "Robohand_struct.h"
#include "pico/mutex.h"

/**
 * @brief Calibration data structure for the BME280 sensor
 */
bme280_calib_data bme280_calib;

/**
 * @brief Calibration data structure for the BME280 sensor
 */
rgb_state rgb_conf;

/**
 * @brief Global structure holding all sensor readings
 */
sensor_data sensor_readings;

/**
 * @brief Global structure containing servo states
 */
servo_motion_profile servo_profiles[NUM_SERVOS];

/**
 * @brief Global structure holding all system status members
 */
system_status sys_status;

/**
 * @brief Initialize the RGB state structure
 * @param[in,out] rgb_struct Pointer to the rgb_state structure to initialize
 */
void init_rgb_state_struct(rgb_state* rgb_struct) {
    if (rgb_struct == NULL) {
        return;
    }
    
    // Initialize all values to safe defaults
    rgb_struct->blink_active = false;
    rgb_struct->blink_state = false;
    rgb_struct->current_r = 0;
    rgb_struct->current_g = 0;
    rgb_struct->current_b = 0;
    rgb_struct->pwm_wrap = 65535;  // Max value for 16-bit PWM
    rgb_struct->blink_interval = 500;  // 500ms default blink interval
    rgb_struct->current_brightness = 0.0f;
    
    // Initialize mutexes
    mutex_init(&rgb_struct->rgb_mutex);
    mutex_init(&rgb_struct->pwm_mutex);
}

/**
 * @brief Initialize the sensor data structure
 * @param[in,out] sensor_struct Pointer to the sensor_data structure to initialize
 */
void init_sensor_data_struct(sensor_data* sensor_struct) {
    if (sensor_struct == NULL) {
        return;
    }
    
    // Initialize all arrays to zero
    memset(sensor_struct->accel, 0, sizeof(sensor_struct->accel));
    memset(sensor_struct->gyro, 0, sizeof(sensor_struct->gyro));
    memset(sensor_struct->mag, 0, sizeof(sensor_struct->mag));
    memset(sensor_struct->adc_values, 0, sizeof(sensor_struct->adc_values));
    
    // Initialize scalar values
    sensor_struct->pressure = 0.0f;
    sensor_struct->altitude = 0.0f;
    sensor_struct->temperature = 0.0f;
    sensor_struct->humidity = 0.0f;
    
    // Initialize mutex
    mutex_init(&sensor_struct->data_mutex);
}

/**
 * @brief Initialize the sensor physical data structure
 * @param[in,out] sensor_struct Pointer to the sensor_data_physical structure to initialize
 */
void init_sensor_data_physical_struct(sensor_data_physical* sensor_struct) {
    if (sensor_struct == NULL) {
        return;
    }
    
    // Initialize all arrays to zero
    memset(sensor_struct->accel, 0, sizeof(sensor_struct->accel));
    memset(sensor_struct->gyro, 0, sizeof(sensor_struct->gyro));
    memset(sensor_struct->mag, 0, sizeof(sensor_struct->mag));
    memset(sensor_struct->adc_values, 0, sizeof(sensor_struct->adc_values));
    
    // Initialize scalar values
    sensor_struct->altitude = 0.0f;
    
    // Initialize mutex
    mutex_init(&sensor_struct->data_mutex);
}

/**
 * @brief Initialize a servo motion profile structure
 * @param[in,out] servo_profile Pointer to the servo_motion_profile structure to initialize
 * @param[in] pwm_pin GPIO pin number to use for this servo
 */
void init_servo_motion_profile_struct(servo_motion_profile* servo_profile, uint8_t pwm_pin) {
    if (servo_profile == NULL) {
        return;
    }
    
    // Initialize with safe default values
    servo_profile->pin = pwm_pin;
    servo_profile->is_moving = false;
    servo_profile->current_pw = 1500;  // Typical center position (1500µs)
    servo_profile->target_pw = 1500;   // Same as current position
    servo_profile->duration_ms = 0;    // No movement duration
    servo_profile->start_time = 0;     // No start time
    
    // Initialize mutex
    mutex_init(&servo_profile->profile_mutex);
}

/**
 * @brief Initialize the system status structure
 * @param[in,out] sys_stat Pointer to the system_status structure to initialize
 */
void init_system_status_struct(system_status* sys_stat) {
    if (sys_stat == NULL) {
        return;
    }
    
    // Initialize with safe default values
    sys_stat->core0_loops = 0;
    sys_stat->core1_loops = 0;
    sys_stat->last_update = 0;
    sys_stat->core0_load = 0.0f;
    sys_stat->core1_load = 0.0f;
    sys_stat->last_watchdog = 0;
    sys_stat->system_ok = true;
    sys_stat->emergency_stop = false;
    
    // Initialize mutex
    mutex_init(&sys_stat->status_mutex);
}

/**
 * @brief Clean up resources used by an RGB state structure
 * @param[in,out] rgb_struct Pointer to the rgb_state structure to destroy
 */
void destroy_rgb_state_struct(rgb_state* rgb_struct) {
    if (rgb_struct == NULL) {
        return;
    }
    
    // Release any resources used by the mutexes
    // Note: In the Raspberry Pi Pico SDK, mutex_deinit() isn't a function
    // but we'll include the logic for potential future compatibility
    
    // Reset all values to safe defaults
    rgb_struct->blink_active = false;
    rgb_struct->current_r = 255;
    rgb_struct->current_g = 0;
    rgb_struct->current_b = 0;
    rgb_struct->current_brightness = 1.0f;
}

/**
 * @brief Clean up resources used by a sensor data structure
 * @param[in,out] sensor_struct Pointer to the sensor_data structure to destroy
 */
void destroy_sensor_data_struct(sensor_data* sensor_struct) {
    if (sensor_struct == NULL) {
        return;
    }
    
    // Reset all values to zero for safety
    memset(sensor_struct->accel, 0, sizeof(sensor_struct->accel));
    memset(sensor_struct->gyro, 0, sizeof(sensor_struct->gyro));
    memset(sensor_struct->mag, 0, sizeof(sensor_struct->mag));
    memset(sensor_struct->adc_values, 0, sizeof(sensor_struct->adc_values));
    
    sensor_struct->pressure = 0.0f;
    sensor_struct->altitude = 0.0f;
    sensor_struct->temperature = 0.0f;
    sensor_struct->humidity = 0.0f;
}

/**
 * @brief Clean up resources used by a physical sensor data structure
 * @param[in,out] sensor_struct Pointer to the sensor_data_physical structure to destroy
 */
void destroy_sensor_data_physical_struct(sensor_data_physical* sensor_struct) {
    if (sensor_struct == NULL) {
        return;
    }
    
    // Reset all values to zero for safety
    memset(sensor_struct->accel, 0, sizeof(sensor_struct->accel));
    memset(sensor_struct->gyro, 0, sizeof(sensor_struct->gyro));
    memset(sensor_struct->mag, 0, sizeof(sensor_struct->mag));
    memset(sensor_struct->adc_values, 0, sizeof(sensor_struct->adc_values));
    
    sensor_struct->altitude = 0.0f;
}

/**
 * @brief Clean up resources used by a servo motion profile structure
 * @param[in,out] servo_profile Pointer to the servo_motion_profile structure to destroy
 */
void destroy_servo_motion_profile_struct(servo_motion_profile* servo_profile) {
    if (servo_profile == NULL) {
        return;
    }
    
    // Stop any active movement for safety
    servo_profile->is_moving = false;
    
    // Reset values to safe defaults
    servo_profile->current_pw = 1500;  // Center position
    servo_profile->target_pw = 1500;   // Same as current position
    servo_profile->duration_ms = 0;    // No movement duration
    servo_profile->start_time = 0;     // No start time
}

/**
 * @brief Clean up resources used by a system status structure
 * @param[in,out] sys_stat Pointer to the system_status structure to destroy
 */
void destroy_system_status_struct(system_status* sys_stat) {
    if (sys_stat == NULL) {
        return;
    }
    
    // Reset counters and flags
    sys_stat->core0_loops = 0;
    sys_stat->core1_loops = 0;
    sys_stat->last_update = 0;
    sys_stat->core0_load = 0.0f;
    sys_stat->core1_load = 0.0f;
    sys_stat->last_watchdog = 0;
    
    // Set system to a safe state before destruction
    sys_stat->emergency_stop = true;
    sys_stat->system_ok = false;
}

 /*!
  * @brief Retrieves the current status of the system.
  * @param[out] dest Pointer to system_status structure to populate.
  */
 void get_system_status(system_status* dest) {
    if (dest == NULL) {
        if (DEBUG > 0) {
            printf("Error: Null pointer in get_system_status\r\n");
        }
        return;
    }

    // Try to get mutex with a timeout
    bool mutex_acquired = mutex_enter_timeout_ms(&sys_status.status_mutex, 50);
    
    if (mutex_acquired) {
        // Get current time for calculations
        uint32_t current_time = time_us_32();
        uint32_t time_elapsed = current_time - sys_status.last_update;
        
        // Copy all data
        memcpy(dest, &sys_status, sizeof(system_status));
        
        // Calculate loads if enough time has passed
        if (time_elapsed > 0) {
            float seconds_elapsed = (float)time_elapsed / 1000000.0f;
            if (seconds_elapsed > 0.001f) { // Avoid division by tiny numbers
                dest->core0_load = (float)sys_status.core0_loops / (seconds_elapsed * 1000.0f);
                dest->core1_load = (float)sys_status.core1_loops / (seconds_elapsed * 1000.0f);
            }
        }
        
        // Reset counters and update timestamp
        sys_status.core0_loops = 0;
        sys_status.core1_loops = 0;
        sys_status.last_update = current_time;
        
        mutex_exit(&sys_status.status_mutex);
    }
    
    else {
        // If we couldn't get the mutex, still provide some data
        memset(dest, 0, sizeof(system_status));
        dest->system_ok = false; // Indicate system issue
        
        if (DEBUG > 0) {
            printf("Warning: Could not acquire system status mutex\r\n");
        }
    }
}



/** @defgroup sensor_data_impl Sensor Data Implementation
*  @brief Implementation of sensor data functions.
*  @{
*/
 
/*!
 * @brief Retrieves current sensor data in a thread-safe manner.
 * @param[out] dest Pointer to sensor_data structure to receive readings.
 * @return true if data copied successfully, false if mutex was busy.
 * @pre dest points to a valid sensor_data object.
 * @warning Caller must allocate destination buffer. Data valid until next update.
 */
bool get_sensor_data(sensor_data* dest) {
    // If user hasn't allocated the array, do it
    if (dest == NULL) {
        init_sensor_data_struct(dest);
        return false;
    }

    mutex_enter_blocking(&sensor_readings.data_mutex);
    memcpy(dest, &sensor_readings, sizeof(sensor_data));
    mutex_exit(&sensor_readings.data_mutex);

    return true;
}

/*!
 * @brief Converts passed sensor data to physical parameters.
 * @param[in] raw Pointer to sensor_data structure to containing unconverted values.
 * @param[out] converted Pointer to sensor_data_physical structure to receive readings as physical parameters.
 * @return true if data copied successfully, false if mutex was busy.
 * @warning Caller must allocate destination buffer. Data valid until next update.
 */
bool convert_sensor_data(const sensor_data* raw, sensor_data_physical* converted) {
    if (!raw || !converted) {
        if (DEBUG > 0) {
            printf("Error: Received NULL parameter\r\n");
        }

        return false;
    }

    // MPU6050 Accelerometer conversion (±2g range: 16384 LSB/g)
    for (int i = 0; i < 3; i++) {
        converted->accel[i] = raw->accel[i] / 16384.0f;
    }

    // MPU6050 Gyroscope conversion (±250dps range: 131 LSB/dps)
    for (int i = 0; i < 3; i++) {
        converted->gyro[i] = raw->gyro[i] / 131.0f;
    }

    // QMC5883L Magnetometer conversion (0.92 mGauss/LSB to µT)
    for (int i = 0; i < 3; i++) {
        converted->mag[i] = raw->mag[i] * 0.92f * 0.1f; // 1 mGauss = 0.1 µT
    }

    // ADC values (already in volts)
    memcpy(converted->adc_values, raw->adc_values, sizeof(raw->adc_values));
    
    // Copy altitude data
    converted->altitude = raw->altitude;

    return true;
}



/** @} */ // end of sensor_data_impl/*!
 * \file Robohand_timing.c
 * \brief Timing functionality for performance evaluation.
 * \details Only fucntional when the debugging flag is > 0.
 * \author Robert Fudge <rnfudge@mun.ca>
 * \date 2025
 * \copyright Apache 2.0 License
 */

#include "Robohand.h"
#include "Robohand_timing.h"

#include <stdio.h>
#include <string.h>

#include "pico/mutex.h"

#if DEBUG > 0

// Timing statistics structure
typedef struct {
    const char* function_name;
    uint32_t call_count;
    uint32_t total_time_us;
    uint32_t min_time_us;
    uint32_t max_time_us;
} timing_stats_t;

#define MAX_TIMING_ENTRIES 50
static timing_stats_t timing_data[MAX_TIMING_ENTRIES];
static int timing_count = 0;
static mutex_t timing_mutex;

void timing_init(void) {
    mutex_init(&timing_mutex);
    memset(timing_data, 0, sizeof(timing_data));
    timing_count = 0;
}

uint32_t timing_start(void) {
    return time_us_32();
}

void timing_end(const char* func_name, uint32_t start_time) {
    uint32_t elapsed = time_us_32() - start_time;
    
    mutex_enter_blocking(&timing_mutex);
    
    // Look for existing entry
    int idx = -1;
    for (int i = 0; i < timing_count; i++) {
        if (strcmp(timing_data[i].function_name, func_name) == 0) {
            idx = i;
            break;
        }
    }
    
    // Create new entry if not found
    if (idx == -1) {
        if (timing_count < MAX_TIMING_ENTRIES) {
            idx = timing_count++;
            timing_data[idx].function_name = func_name;
            timing_data[idx].min_time_us = UINT32_MAX;
        } else {
            // No more space for new entries
            mutex_exit(&timing_mutex);
            return;
        }
    }
    
    // Update statistics
    timing_data[idx].call_count++;
    timing_data[idx].total_time_us += elapsed;
    
    if (elapsed < timing_data[idx].min_time_us)
        timing_data[idx].min_time_us = elapsed;
        
    if (elapsed > timing_data[idx].max_time_us)
        timing_data[idx].max_time_us = elapsed;
        
    mutex_exit(&timing_mutex);
}

void timing_print_report(void) {
    mutex_enter_blocking(&timing_mutex);
    
    printf("\n===== TIMING REPORT =====\n");
    printf("%-30s %10s %10s %10s %10s\n", 
        "Function", "Calls", "Total(us)", "Avg(us)", "Max(us)");
    printf("---------------------------------------------------------------\n");
    
    for (int i = 0; i < timing_count; i++) {
        float avg = (float)timing_data[i].total_time_us / 
            ((float) timing_data[i].call_count > 0 ? (float) timing_data[i].call_count : 1);
                    
        printf("%-30s %10lu %10lu %10.1f %10lu\n",
            timing_data[i].function_name,
            timing_data[i].call_count,
            timing_data[i].total_time_us,
            avg,
            timing_data[i].max_time_us);
    }
    
    printf("=========================\n");
    mutex_exit(&timing_mutex);
}

#endif // DEBUG > 0/*!
* @file Robohand_uros.c
* @brief MicroROS interface for robotic hand control system.
* @details Facilitates communication with ROS2 systems using MicroROS.
* @author Robert Fudge <rnfudge@mun.ca>
* @date 2025
* @copyright Apache 2.0 License
*/

#include "Robohand_init.h"
#include "Robohand_rgb.h"
#include "Robohand_servos.h"
#include "Robohand_uros.h"

#include <stdio.h>
#include <string.h>

#include <pico/stdlib.h>
#include <pico/time.h>

// MicroROS includes
#include <rcl/rcl.h>
#include <rcl/error_handling.h>
#include <rclc/rclc.h>
#include <rclc/executor.h>
#include <rmw_microros/rmw_microros.h>

// MicroROS message types
#include <std_msgs/msg/int32.h>
#include <std_msgs/msg/float32_multi_array.h>
#include <std_msgs/msg/string.h>
#include <std_msgs/msg/header.h>

// Transport-specific includes
#include <rmw_microros/rmw_microros.h>
#include "./Dependencies/micro_ros_pico_sdk/pico_uart_transports.h"

// MicroROS state
rcl_publisher_t sensor_publisher;
rcl_publisher_t status_publisher;
rcl_subscription_t servo_subscription;

// Message buffers
std_msgs__msg__Float32MultiArray sensor_msg;
std_msgs__msg__String status_msg;
std_msgs__msg__Int32 servo_msg;

// ROS node and support objects
rclc_executor_t executor;
rclc_support_t support;
rcl_allocator_t allocator;
rcl_node_t node;

// Timer for publishing sensor data
rcl_timer_t sensor_timer;

#define RCCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)) { printf("MICROROS ERROR: %d\r\n", (int)temp_rc); } }
#define RCSOFTCHECK(fn) { rcl_ret_t temp_rc = fn; if((temp_rc != RCL_RET_OK)) { } }

// Function prototypes
void error_loop();
void servo_callback(const void * msgin);
void timer_callback(rcl_timer_t * timer, int64_t last_call_time);

int main() {
    // Initialize standard Pico functionality
    stdio_init_all();
    sleep_ms(2000); // Give the system time to stabilize
    
    printf("\nRoboHand MicroROS Interface\r\n");
    
    // Initialize the robotic hand system
    init_robohand_system();
    
    if (HAS_RGB) {
        init_rgb();
        rgb_set_color(0, 0, 255); // Blue indicates initializing
    }
    
    // Initialize MicroROS allocator
    allocator = rcl_get_default_allocator();
    
    // Initialize transport - platform specific
    rmw_uros_set_custom_transport(
        true,
        NULL,
        pico_serial_transport_open,
        pico_serial_transport_close,
        pico_serial_transport_write,
        pico_serial_transport_read
    );
    
    printf("Waiting for agent...\r\n");
    
    // Wait for agent - blink LED while waiting
    if (HAS_RGB) {
        rgb_blink(true, 500);
    }
    
    while (RMW_RET_OK != rmw_uros_ping_agent(1000, 120)) {
        // Monitor loop
        tight_loop_contents();
    }
    
    if (HAS_RGB) {
        rgb_blink(false, 0);
        rgb_set_color(0, 255, 0); // Green indicates connected
    }
    
    printf("Agent found, initializing...\r\n");
    
    // Initialize ROS context
    RCCHECK(rclc_support_init(&support, 0, NULL, &allocator));
    
    // Create node
    RCCHECK(rclc_node_init_default(&node, "robohand_node", "", &support));
    
    // Create publishers
    RCCHECK(rclc_publisher_init_default(
        &sensor_publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Float32MultiArray),
        "robohand/sensors"
    ));
    
    RCCHECK(rclc_publisher_init_default(
        &status_publisher,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, String),
        "robohand/status"
    ));
    
    // Create subscribers
    RCCHECK(rclc_subscription_init_default(
        &servo_subscription,
        &node,
        ROSIDL_GET_MSG_TYPE_SUPPORT(std_msgs, msg, Int32),
        "robohand/servo"
    ));
    
    // Create timer
    RCCHECK(rclc_timer_init_default(
        &sensor_timer,
        &support,
        RCL_MS_TO_NS(100),  // 10 Hz
        timer_callback
    ));
    
    // Initialize executor
    RCCHECK(rclc_executor_init(&executor, &support.context, 2, &allocator));
    RCCHECK(rclc_executor_add_timer(&executor, &sensor_timer));
    RCCHECK(rclc_executor_add_subscription(
        &executor, 
        &servo_subscription, 
        &servo_msg, 
        &servo_callback, 
        ON_NEW_DATA
    ));
    
    // Initialize message
    sensor_msg.data.capacity = 20;  // Allocate space for all sensors
    sensor_msg.data.size = 0;
    sensor_msg.data.data = (float*) malloc(sensor_msg.data.capacity * sizeof(float));
    
    status_msg.data.capacity = 256;
    status_msg.data.size = 0;
    status_msg.data.data = (char*) malloc(status_msg.data.capacity * sizeof(char));
    
    printf("MicroROS initialized, entering spin loop\r\n");
    
    // Main loop
    while (1) {
        // Spin executor
        RCSOFTCHECK(rclc_executor_spin_some(&executor, RCL_MS_TO_NS(10)));
        
        // Update system counters
        mutex_enter_blocking(&sys_status.status_mutex);
        sys_status.core0_loops++;
        mutex_exit(&sys_status.status_mutex);
        
        sleep_ms(1); // Small sleep to prevent tight loop
    }
    
    // Clean up
    RCCHECK(rcl_publisher_fini(&sensor_publisher, &node));
    RCCHECK(rcl_publisher_fini(&status_publisher, &node));
    RCCHECK(rcl_subscription_fini(&servo_subscription, &node));
    RCCHECK(rcl_node_fini(&node));
    RCCHECK(rcl_timer_fini(&sensor_timer));
    RCCHECK(rclc_executor_fini(&executor));
    RCCHECK(rclc_support_fini(&support));
    
    free(sensor_msg.data.data);
    free(status_msg.data.data);
    
    return 0;
}

// Error indicator
void error_loop() {
    if (HAS_RGB) {
        rgb_set_color(255, 0, 0); // Red indicates error
        rgb_blink(true, 200);     // Fast blink for error state
    }
    
    while (1) {
        printf("Error: MicroROS failure\r\n");
        sleep_ms(1000);
    }
}

// ROS timer callback for publishing sensor data
void timer_callback(rcl_timer_t * timer, int64_t last_call_time) {
    (void) last_call_time;
    if (timer == NULL) {
        return;
    }
    
    // Read sensor data
    sensor_data local_data;
    sensor_data_physical physical_data;
    
    if (get_sensor_data(&local_data)) {
        convert_sensor_data(&local_data, &physical_data);
        
        //Reset message
        sensor_msg.data.size = 0;
        
        // Add accelerometer data
        for (int i = 0; i < 3; i++) {
            sensor_msg.data.data[sensor_msg.data.size++] = physical_data.accel[i];
        }
        
        // Add gyro data
        for (int i = 0; i < 3; i++) {
            sensor_msg.data.data[sensor_msg.data.size++] = physical_data.gyro[i];
        }
        
        // Add mag data
        for (int i = 0; i < 3; i++) {
            sensor_msg.data.data[sensor_msg.data.size++] = physical_data.mag[i];
        }
        
        // Add ADC values
        for (int i = 0; i < 5; i++) {
            sensor_msg.data.data[sensor_msg.data.size++] = physical_data.adc_values[i];
        }
        
        // Add altitude
        sensor_msg.data.data[sensor_msg.data.size++] = physical_data.altitude;
        
        // Publish
        RCSOFTCHECK(rcl_publish(&sensor_publisher, &sensor_msg, NULL));
    }
    
    // Read system status
    system_status local_status;
    get_system_status(&local_status);
    
    // Format status string
    char status_buffer[256];
    snprintf(status_buffer, 256, 
             "C0:%lu,C1:%lu,OK:%d,ES:%d,L0:%.2f,L1:%.2f",
             local_status.core0_loops, 
             local_status.core1_loops,
             local_status.system_ok ? 1 : 0,
             local_status.emergency_stop ? 1 : 0,
             local_status.core0_load,
             local_status.core1_load);
    
    // Update status message
    status_msg.data.size = strlen(status_buffer);
    memcpy(status_msg.data.data, status_buffer, status_msg.data.size);
    
    // Publish
    RCSOFTCHECK(rcl_publish(&status_publisher, &status_msg, NULL));
}

// ROS subscription callback for servo commands
void servo_callback(const void * msgin) {
    const std_msgs__msg__Int32 * msg = (const std_msgs__msg__Int32 *)msgin;
    
    if (msg == NULL) return;
    
    // Command format: SSPPPDDD (Servo, Position, Duration)
    // S: 1 digit for servo index (0-4)
    // P: 4 digits for pulse width (0500-2500)
    // D: 4 digits for duration in ms (0100-9999)
    
    int32_t cmd = msg->data;
    
    if (cmd < 0) {
        // Negative values are interpreted as emergency stop
        mutex_enter_blocking(&sys_status.status_mutex);
        sys_status.emergency_stop = true;
        mutex_exit(&sys_status.status_mutex);
        return;
    }
    
    // Extract command components
    uint8_t servo = (cmd / 100000000) % 10;
    uint16_t position = (cmd / 10000) % 10000;
    uint16_t duration = cmd % 10000;
    
    // Check bounds
    if (servo >= NUM_SERVOS) return;
    if (position < SERVO_MIN_PULSE || position > SERVO_MAX_PULSE) return;
    if (duration < 100 || duration > MAX_MOVE_DURATION_MS) return;
    
    // Execute the command
    actuate_servo(servo, position, duration);
}/*!
* @file Robohand_usb.c
* @brief USB terminal interface for robotic hand control system.
* @details Provides an interactive terminal for monitoring and controlling the hand.
* @author Robert Fudge <rnfudge@mun.ca>
* @date 2025
* @copyright Apache 2.0 License
*/

#include "Robohand.h"
#include "Robohand_dma.h"
#include "Robohand_callbacks.h"
#include "Robohand_i2c.h"
#include "Robohand_interrupts.h"
#include "Robohand_struct.h"
#include "Robohand_servos.h"
#include "Robohand_rgb.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <ctype.h>

#include "pico/multicore.h"
#include "hardware/watchdog.h"

#define CMD_BUFFER_SIZE 256
#define MAX_ARGS 10
#define TELEMETRY_INTERVAL_MS 1000  //Default telemetry update interval

//Function prototypes
static void process_command(char* cmd_buffer);
static void print_help(void);
static void handle_servo_command(int argc, char** argv);
static void handle_sensor_command(void);
static void handle_status_command(void);
static void handle_rgb_command(int argc, char** argv);
static void handle_blink_command(int argc, char** argv);
static void handle_core_debug(int argc, char** argv);
static void handle_debug_command(int argc, char** argv);
static bool timer_callback(struct repeating_timer *t);

static void handle_input_char(int c, char *cmd_buffer, int *cmd_pos);
static void handle_telemetry_command(int argc, char **argv);

//Global variables
static struct repeating_timer telemetry_timer;
static bool telemetry_enabled = false;
static uint32_t loop_counter = 0;
static absolute_time_t last_time;

/*!
* @brief Main entry point for the USB interface.
* @return Should never return in normal operation.
*/
static void handle_input_char(int c, char *cmd_buffer, int *cmd_pos) {
    if (c == '\r' || c == '\n') {
        //Process Enter key
        printf("\r\n");  // Echo newline
        
        //Null-terminate the command
        cmd_buffer[*cmd_pos] = '\0';
        
        //Process command if not empty
        if (*cmd_pos > 0) {
            process_command(cmd_buffer);
        }
        
        //Reset buffer
        *cmd_pos = 0;
        return;
    } 
    
    if (c == 127 || c == '\b') {
        //Process Backspace key
        if (*cmd_pos > 0) {
            //Move cursor back, print space, move cursor back again
            printf("\b \b");
            (*cmd_pos)--;
        }
        return;
    }
    
    if (c == 3) {
        //Process Ctrl+C - clear current line
        printf("^C\r\n");
        *cmd_pos = 0;
        return;
    }
    
    if (c >= 32 && c <= 126 && *cmd_pos < (CMD_BUFFER_SIZE - 1)) {
        //Process printable characters
        putchar(c);  //Echo character
        cmd_buffer[(*cmd_pos)++] = (char)c;
    }
}

/*!
* @brief Main entry point for the USB interface.
* @return Should never return in normal operation.
*/
int main() {
    //Initialize standard I/O
    stdio_init_all();
    
    //Small delay to allow for USB connection
    sleep_ms(2000);
    
    //Clear the terminal screen 
    printf("\033[2J\033[H");  //ANSI escape sequence to clear screen
    
    printf("RoboHand USB Interface v1.0\r\n");
    printf("Type 'help' for available commands\r\n\n");
    
    //Initialize the robotic hand system
    init_robohand_system();
    
    if (HAS_RGB) {
        init_rgb();
        rgb_set_color(0, 100, 0);  //Set initial color to green
    }
    
    char cmd_buffer[CMD_BUFFER_SIZE];
    int cmd_pos = 0;
    last_time = get_absolute_time();
    
    //Command processing loop
    while (true) {
		static bool printed = false;
        //Print prompt if buffer is empty
        if (cmd_pos == 0 && printed == false) {
            printf("robohand> ");
            fflush(stdout);
			printed = true;
        }
        
        //Check for incoming characters
        int c = getchar_timeout_us(10000);  //10ms timeout
        
        if (c != PICO_ERROR_TIMEOUT) {
            handle_input_char(c, cmd_buffer, &cmd_pos);
        }

		if (c == '\r' || c == '\n') {
			printed = false;
		}
        
        //Update system counters
        mutex_enter_blocking(&sys_status.status_mutex);
        sys_status.core0_loops++;
        mutex_exit(&sys_status.status_mutex);
        loop_counter++;
        
        //Calculate load every second
        if (absolute_time_diff_us(last_time, get_absolute_time()) >= 1000000) {
            last_time = get_absolute_time();
            loop_counter = 0;
        }
    }
}

/*!
* @brief Process a command string from the terminal.
* @param cmd_buffer The null-terminated command string.
*/
static void process_command(char *cmd_buffer) {
    //Skip leading whitespace
    while (isspace(*cmd_buffer)) cmd_buffer++;
    
    //Check for empty command
    if (*cmd_buffer == '\0') return;
    
    //Split command into tokens
    char *argv[MAX_ARGS];
    int argc = 0;
    char *saveptr; //Save pointer for strtok_r
    
    char *token = strtok_r(cmd_buffer, " \t", &saveptr);
    while (token != NULL && argc < MAX_ARGS) {
        argv[argc++] = token;
        token = strtok_r(NULL, " \t", &saveptr);
    }
    
    //Exit early if no arguments
    if (argc == 0) return;
    
    //Handle commands with function calls to reduce nesting
    if (strcmp(argv[0], "help") == 0) {
        print_help();
        return;
    }
    
    if (strcmp(argv[0], "servo") == 0) {
        handle_servo_command(argc, argv);
        return;
    }
    
    if (strcmp(argv[0], "sensors") == 0) {
        handle_sensor_command();
        return;
    }
    
    if (strcmp(argv[0], "status") == 0) {
        handle_status_command();
        return;
    }
    
    if (strcmp(argv[0], "rgb") == 0) {
        handle_rgb_command(argc, argv);
        return;
    }
    
    if (strcmp(argv[0], "blink") == 0) {
        handle_blink_command(argc, argv);
        return;
    }

	if (strcmp(argv[0], "coredebug") == 0) {
		handle_core_debug(argc, argv);
		return;
	}

	if (strcmp(argv[0], "debug") == 0) {
		handle_debug_command(argc, argv);
		return;
	}
    
    if (strcmp(argv[0], "telemetry") == 0) {
        handle_telemetry_command(argc, argv);
        return;
    }
    
    if (strcmp(argv[0], "reset") == 0) {
        printf("Resetting system...\r\n");
        watchdog_enable(1, false);  //Enable watchdog with 1ms timeout
        while (1) tight_loop_contents();  //Wait for watchdog to reset
    }
    
    //If we get here, command wasn't recognized
    printf("Unknown command: %s\r\n", argv[0]);
    printf("Type 'help' for available commands\r\n");
}

/*!
* @brief Main entry point for the USB interface.
* @return Should never return in normal operation.
*/
static void handle_telemetry_command(int argc, char **argv) {
    if (argc < 2) {
        printf("Usage: telemetry <on|off> [interval_ms]\r\n");
        return;
    }
    
    if (strcmp(argv[1], "on") == 0) {
        int interval = TELEMETRY_INTERVAL_MS;
        if (argc > 2) {
            interval = atoi(argv[2]);
            if (interval < 100) interval = 100;  //Minimum 100ms
        }
        
        if (telemetry_enabled) {
            cancel_repeating_timer(&telemetry_timer);
        }
        
        add_repeating_timer_ms(-interval, timer_callback, NULL, &telemetry_timer);
        telemetry_enabled = true;
        printf("Telemetry enabled (%dms interval)\r\n", interval);
        return;
    }
    
    if (strcmp(argv[1], "off") == 0) {
        if (telemetry_enabled) {
            cancel_repeating_timer(&telemetry_timer);
            telemetry_enabled = false;
            printf("Telemetry disabled\r\n");
        }
        return;
    }
    
    printf("Usage: telemetry <on|off> [interval_ms]\r\n");
}

/*!
* @brief Print help information.
*/
static void print_help(void) {
	printf("Available commands:\r\n");
	printf("  help                     - Show this help message\r\n");
	printf("  servo <id> <pos> <time>  - Move servo (id:0-4, pos:500-2500µs, time:ms)\r\n");
	printf("  sensors                  - Show current sensor readings\r\n");
	printf("  status                   - Show system status\r\n");
	printf("  rgb <r> <g> <b>          - Set RGB LED color (0-255)\r\n");
	printf("  blink <on|off> <time>    - Control LED blinking (time:ms)\r\n");
	printf("  telemetry <on|off> [ms]  - Enable/disable periodic updates\r\n");
	printf("  reset                    - Reset the system\r\n");
}

/*!
* @brief Handle servo movement command.
* @param argc Argument count.
* @param argv Argument values.
*/
static void handle_servo_command(int argc, char **argv) {
	if (argc < 4) {
		printf("Usage: servo <id> <position> <time>\r\n");
		printf("  id: 0-%d (servo index)\r\n", NUM_SERVOS-1);
		printf("  position: %d-%d (pulse width in µs)\r\n", SERVO_MIN_PULSE, SERVO_MAX_PULSE);
		printf("  time: milliseconds for movement\r\n");
		return;
	}
	
	if (!HAS_SERVOS) {
		printf("Servo support is disabled in configuration\r\n");
		return;
	}
	
	uint8_t servo = (uint8_t) atoi(argv[1]);
	uint16_t position = (uint16_t) atoi(argv[2]);
	uint16_t duration = (uint16_t) atoi(argv[3]);
	
	if (servo >= NUM_SERVOS) {
		printf("Error: Servo index must be 0-%d\r\n", NUM_SERVOS-1);
		return;
	}
	
	//Constrain values
	position = constrain_u16(position, SERVO_MIN_PULSE, SERVO_MAX_PULSE);
	duration = constrain_u16(duration, 100, MAX_MOVE_DURATION_MS);
	
	printf("Moving servo %d to position %d over %d ms\r\n", servo, position, duration);
	actuate_servo(servo, position, duration);
}

/*!
* @brief Handle sensor reading command.
*/
static void handle_sensor_command(void) {
	sensor_data sensor_values;
	sensor_data_physical physical_values;
	
	if (get_sensor_data(&sensor_values)) {
		convert_sensor_data(&sensor_values, &physical_values);
		
		printf("Sensor Readings:\r\n");
		printf("Accelerometer (g):  X: %.2f  Y: %.2f  Z: %.2f\r\n", 
			physical_values.accel[0], physical_values.accel[1], physical_values.accel[2]);
		
		printf("Gyroscope (°/s):    X: %.2f  Y: %.2f  Z: %.2f\r\n", 
			physical_values.gyro[0], physical_values.gyro[1], physical_values.gyro[2]);
		
		printf("Magnetometer (µT):  X: %.2f  Y: %.2f  Z: %.2f\r\n", 
			physical_values.mag[0], physical_values.mag[1], physical_values.mag[2]);
		
		printf("ADC Voltages (V):   ");
		for (int i = 0; i < 5; i++) {
			printf("CH%d: %.3f  ", i, physical_values.adc_values[i]);
		}
		printf("\r\n");
		
		printf("Altitude: %.2f m\r\n", physical_values.altitude);
	} else {
		printf("Error: Failed to read sensor data\r\n");
	}
}

/*!
* @brief Handle system status command.
*/
static void handle_status_command(void) {
    system_status status;
    get_system_status(&status);
    
    printf("System Status:\r\n");
    printf("Core 0 Load: %.2f loops/ms\r\n", status.core0_load);
    printf("Core 1 Load: %.2f loops/ms\r\n", status.core1_load);
    printf("System OK: %s\r\n", status.system_ok ? "Yes" : "No");
    printf("Emergency Stop: %s\r\n", status.emergency_stop ? "Active" : "Inactive");
    
    //Convert to seconds for more readable output
    float seconds_since_watchdog = (float) (time_us_32() - status.last_watchdog) / 1000000.0f;
    printf("Last Watchdog: %.1f seconds ago\r\n", seconds_since_watchdog);
    
    //Add configuration info
    printf("\nSystem Configuration:\r\n");
    printf("USE_INTERRUPTS: %s\r\n", USE_INTERRUPTS ? "Yes" : "No");
    printf("USE_DMA: %s\r\n", USE_DMA ? "Yes" : "No");
    printf("USE_CALLBACKS: %s\r\n", USE_CALLBACKS ? "Yes" : "No");
    
    printf("\nHardware Configuration:\r\n");
    printf("HAS_ADS1115: %s\r\n", HAS_ADS1115 ? "Yes" : "No");
    printf("HAS_BME280: %s\r\n", HAS_BME280 ? "Yes" : "No");
    printf("HAS_QMC5883L: %s\r\n", HAS_QMC5883L ? "Yes" : "No");
    printf("HAS_MPU6050: %s\r\n", HAS_MPU6050 ? "Yes" : "No");
    printf("HAS_PI_ADC: %s\r\n", HAS_PI_ADC ? "Yes" : "No");
    printf("HAS_RGB: %s\r\n", HAS_RGB ? "Yes" : "No");
    printf("HAS_SERVOS: %s\r\n", HAS_SERVOS ? "Yes" : "No");
    
    //Show servo status if enabled
    if (HAS_SERVOS) {
        printf("\nServo Status:\r\n");
        for (uint8_t i = 0; i < NUM_SERVOS; i++) {
            servo_motion_profile profile;
            if (get_servo_status(i, &profile)) {
                printf("Servo %d: Pos=%d µs  Target=%d µs  Moving=%s\r\n",
                       i, profile.current_pw, profile.target_pw,
                       profile.is_moving ? "Yes" : "No");
            } else {
                printf("Servo %d: Status unavailable\r\n", i);
            }
        }
    }
}

/*!
* @brief Handle RGB LED color command.
* @param argc Argument count.
* @param argv Argument values.
*/
static void handle_rgb_command(int argc, char **argv) {
	if (!HAS_RGB) {
		printf("RGB LED support is disabled in configuration\r\n");
		return;
	}
	
	if (argc < 4) {
		printf("Usage: rgb <r> <g> <b>\r\n");
		printf("  r,g,b: 0-255 (color values)\r\n");
		return;
	}
	
	uint8_t r = (uint8_t) abs(atoi(argv[1]));
	uint8_t g = (uint8_t) abs(atoi(argv[2]));
	uint8_t b = (uint8_t) abs(atoi(argv[3]));
	
	rgb_set_color(r, g, b);
	printf("RGB color set to (%d, %d, %d)\r\n", r, g, b);
}

/*!
* @brief Handle LED blinking command.
* @param argc Argument count.
* @param argv Argument values.
*/
static void handle_blink_command(int argc, char **argv) {
	if (!HAS_RGB) {
		printf("RGB LED support is disabled in configuration\r\n");
		return;
	}
	
	if (argc < 2) {
		printf("Usage: blink <on|off> [interval_ms]\r\n");
		return;
	}
	
	if (strcmp(argv[1], "on") == 0) {
		uint32_t interval = 500;  //Default 500ms
		if (argc > 2) {
			interval = (uint32_t) abs(atoi(argv[2]));
			if (interval < 50) interval = 50;  //Minimum 50ms
		}
		
		rgb_blink(true, interval);
		printf("LED blinking enabled (%lu ms interval)\r\n", interval);
	}
	else if (strcmp(argv[1], "off") == 0) {
		rgb_blink(false, 0);
		printf("LED blinking disabled\r\n");
	}
	else {
		printf("Usage: blink <on|off> [interval_ms]\r\n");
	}
}
static void handle_debug_command(int argc, char** argv) {
	(void) argc;
	(void) argv;
	
	get_debug_info();
}

static void handle_core_debug(int argc, char** argv) {
	(void) argc;
	(void) argv;
	
	printf("Core Debug Information:\r\n");
		
	//Force synchronization between cores
	printf("Sending ping to Core 1...\r\n");
		
	uint32_t start_time = time_us_32();
		
	//Send ping signal to core 1
	multicore_fifo_push_blocking(0xDEAD);
		
	//Wait for response with timeout
	bool response = false;
	for (int i = 0; i < 10; i++) {  // Try for ~1 second
		if (multicore_fifo_rvalid()) {
			uint32_t response_val = multicore_fifo_pop_blocking();
			printf("Core 1 responded with: 0x%08lX\r\n", response_val);
			printf("Round-trip time: %lu microseconds\r\n", time_us_32() - start_time);
			response = true;
			break;
		}
		sleep_ms(100);
	}
		
	if (!response) {
		printf("ERROR: Core 1 did not respond within timeout!\r\n");
		printf("This suggests Core 1 might be locked up or not running properly.\r\n");
	}
}


/*!
* @brief Timer callback for telemetry updates.
* @param t Timer structure.
* @return Always returns true to continue timer.
*/
static bool timer_callback(struct repeating_timer *t) {
	(void)t;  // Unused parameter
	
	// Clear line
	printf("\033[2K\r");  // ANSI escape to clear line
	
	// Show condensed status
	system_status status;
	get_system_status(&status);
	
	printf("C0:%.1f C1:%.1f | ", status.core0_load, status.core1_load);
	
	// Show servo positions
	if (HAS_SERVOS) {
		printf("Servos: ");
		for (int i = 0; i < NUM_SERVOS; i++) {
			servo_motion_profile profile;
			if (get_servo_status((uint8_t) i, &profile)) {
				printf("%d:%d%s ", i, profile.current_pw, 
					profile.is_moving ? "*" : "");
			} else {
				printf("%d:? ", i);
			}
		}
	}
	
	// Add sensor data if available
	sensor_data sensor_values;
	sensor_data_physical physical_values;
	
	if (get_sensor_data(&sensor_values) && 
		convert_sensor_data(&sensor_values, &physical_values)) {
		printf("| ACC:%.1f,%.1f,%.1f", 
			physical_values.accel[0], 
			physical_values.accel[1], 
			physical_values.accel[2]);
	}
	
	// Keep cursor at start of line for next update
	fflush(stdout);
	return true;
}# == DO NOT EDIT THE FOLLOWING LINES for the Raspberry Pi Pico VS Code Extension to work ==
if(WIN32)
    set(USERHOME $ENV{USERPROFILE})
else()
    set(USERHOME $ENV{HOME})
endif()
set(sdkVersion 2.1.1)
set(toolchainVersion 14_2_Rel1)
set(picotoolVersion 2.1.1)
set(picoVscode ${USERHOME}/.pico-sdk/cmake/pico-vscode.cmake)
if (EXISTS ${picoVscode})
    include(${picoVscode})
endif()
# ====================================================================================

#
# @file CMakeLists.txt
# @brief Build configuration for the robotic hand control system.
# @details Sets up targets for different connection backends (USB, Micro-ROS).
# @author Robert Fudge
# @date 2025
# @copyright Apache 2.0 License
#

# Set the minimum CMake version allowed for compilation
cmake_minimum_required(VERSION 3.13)

# Default board type (can be overridden via command line)
set(PICO_BOARD pico CACHE STRING "Board type")

# Standard language settings
set(CMAKE_C_STANDARD 11)
set(CMAKE_CXX_STANDARD 17)
set(CMAKE_EXPORT_COMPILE_COMMANDS ON)

# Project structure configuration
set(PROJECT_NAME Robohand)
set(DEPS_DIR ${CMAKE_CURRENT_SOURCE_DIR}/Dependencies)
set(INCLUDE_DIR ${CMAKE_CURRENT_SOURCE_DIR}/Include)

# Pico SDK configuration
set(PICO_SDK_PATH ${DEPS_DIR}/pico-sdk)
include(${PICO_SDK_PATH}/external/pico_sdk_import.cmake)

# Micro-ROS configuration
set(MICRO_ROS_DIR ${DEPS_DIR}/micro_ros_pico_sdk)
set(MICRO_ROS_PLATFORM_DIR ${MICRO_ROS_DIR}/libmicroros)

# Build options with descriptions
option(USE_INTERRUPTS "Enable interrupt-based data acquisition" OFF)
option(USE_DMA "Enable DMA transfers for sensor data" OFF)
option(ENABLE_DEBUG "Enable detailed debug output" ON)
option(ENABLE_WATCHDOG "Enable watchdog timer for system recovery" ON)

# Main project setup
project(${PROJECT_NAME} C CXX ASM)

# Initialize Pico SDK
pico_sdk_init()
set(PICO_LWIP_COMPILER_FLAGS "-Wno-address-of-packed-member -Wno-unused-but-set-variable")

# Common compile definitions for all targets
set(COMMON_DEFINITIONS
    PICO_DEFAULT_CPU_CLOCK_KHZ=125000
    PICO_FLASH_SPI_CLKDIV=4
    PICO_NO_FLASH=0
)

# Additional definitions based on build options
if(USE_DMA)
    list(APPEND COMMON_DEFINITIONS
        USE_DMA=1
        PICO_DEFAULT_DMA_MAX_CHANNELS=12
    )
endif()

if(USE_INTERRUPTS)
    list(APPEND COMMON_DEFINITIONS
        USE_INTERRUPTS=1
    )
endif()

if(ENABLE_DEBUG)
    list(APPEND COMMON_DEFINITIONS
        DEBUG=1
    )
else()
    list(APPEND COMMON_DEFINITIONS
        DEBUG=0
    )
endif()

if(ENABLE_WATCHDOG)
    list(APPEND COMMON_DEFINITIONS
        WATCHDOG_ENABLED=1
    )
endif()

# Common source files used by all build targets
set(COMMON_SOURCES
    ./Include/Robohand_common.h
    ./Src/Core/Robohand_callbacks.c
    ./Include/Robohand_callbacks.h
    ./Src/Core/Robohand_dma.c
    ./Include/Robohand_dma.h
    ./Src/Core/Robohand_i2c.c
    ./Include/Robohand_i2c.h
    ./Src/Core/Robohand_init.c
    ./Include/Robohand_init.h
    ./Src/Core/Robohand_interrupts.c
    ./Include/Robohand_interrupts.h
    ./Src/Core/Robohand_reader.c
    ./Include/Robohand_reader.h
    ./Src/Core/Robohand_rgb.c
    ./Include/Robohand_rgb.h
    ./Src/Core/Robohand_servos.c
    ./Include/Robohand_servos.h
    ./Src/Core/Robohand_struct.c
    ./Include/Robohand_struct.h
    ./Src/Core/Robohand_timing.c
    ./Include/Robohand_timing.h
    ./Src/Robohand.c
    ./Include/Robohand.h
)

# Set include directories for all targets
include_directories(
    ${CMAKE_CURRENT_SOURCE_DIR}/Include
    ${MICRO_ROS_PLATFORM_DIR}/include
    ${CMAKE_CURRENT_SOURCE_DIR}
)

# Configure imported Micro-ROS library
add_library(microros STATIC IMPORTED)
set_target_properties(microros PROPERTIES
    IMPORTED_LOCATION ${MICRO_ROS_PLATFORM_DIR}/libmicroros.a
    INTERFACE_INCLUDE_DIRECTORIES "${MICRO_ROS_PLATFORM_DIR}/include"
)

# Common libraries required by all targets
set(COMMON_LIBS
    pico_multicore
    pico_stdlib
    pico_time
    hardware_adc
    hardware_dma
    hardware_i2c
    hardware_pio
    hardware_pwm
    hardware_watchdog
)

# Build variants configuration (target suffix : board type)
set(TARGET_VARIANTS
    "_uros:pico"
    "_usb:pico"
)

# Configure each executable variant
foreach(TARGET_INFO IN LISTS TARGET_VARIANTS)
    string(REPLACE ":" ";" TARGET_PARTS ${TARGET_INFO})
    list(GET TARGET_PARTS 0 TARGET_SUFFIX)
    list(GET TARGET_PARTS 1 PICO_BOARD)

    set(TARGET_NAME ${PROJECT_NAME}${TARGET_SUFFIX})
    set(SOURCE_FILE ./Src/Robohand${TARGET_SUFFIX}.c)

    # Handle special case for Micro-ROS target
    if(TARGET_SUFFIX STREQUAL "_uros")
        set(SOURCE_FILE ./Src/Robohand${TARGET_SUFFIX}.c ./Dependencies/micro_ros_pico_sdk/pico_uart_transport.c)
    endif()

    # Create executable target
    add_executable(${TARGET_NAME}
        ${SOURCE_FILE}
        ${COMMON_SOURCES}
    )

    # Configure target board
    set_target_properties(${TARGET_NAME} PROPERTIES 
        PICO_BOARD ${PICO_BOARD}
    )

    # Apply common compile definitions
    target_compile_definitions(${TARGET_NAME} PRIVATE ${COMMON_DEFINITIONS})

    # Set program metadata
    pico_set_program_name(${TARGET_NAME} "${TARGET_NAME}")
    pico_set_program_version(${TARGET_NAME} "0.1")

    # Link common libraries
    target_link_libraries(${TARGET_NAME} ${COMMON_LIBS})

    # Apply target-specific configuration

    # USB interface target configuration
    if(TARGET_SUFFIX STREQUAL "_usb")
        pico_enable_stdio_usb(${TARGET_NAME} 1)
        pico_enable_stdio_uart(${TARGET_NAME} 0)
        target_compile_definitions(${TARGET_NAME} PRIVATE
            PICO_DEFAULT_USB_MANUFACTURER="Robert Fudge"
            PICO_DEFAULT_USB_PRODUCT="Robohand USB interface"
            PICO_TINYUSB_ENABLE_CDC=1
            # Fix for terminal echo and backspace
            PICO_STDIO_USB_ENABLE_RESET_VIA_VENDOR_INTERFACE=1
            PICO_STDIO_USB_ENABLE_STDIO_UART_BUILDING=0
            PICO_STDIO_DEFAULT_CRLF=1
        )

        target_link_libraries(${TARGET_NAME} pico_stdio_usb)
    endif()

    # Micro-ROS target configuration
    if(TARGET_SUFFIX STREQUAL "_uros")
        target_link_libraries(${TARGET_NAME} microros)
        target_include_directories(${TARGET_NAME} PRIVATE
            ${MICRO_ROS_PLATFORM_DIR}
            ${MICRO_ROS_PLATFORM_DIR}/include
        )

        # Disable CRLF handling for Micro-ROS
        target_compile_definitions(${TARGET_NAME} PRIVATE
            PICO_UART_ENABLE_CRLF_SUPPORT=0
            PICO_STDIO_ENABLE_CRLF_SUPPORT=0
            PICO_STDIO_DEFAULT_CRLF=0
        )
    endif()

    # Generate UF2 and other output formats
    pico_add_extra_outputs(${TARGET_NAME})
endforeach()

# Helper target for IDE integration
if(CMAKE_EXPORT_COMPILE_COMMANDS)
    add_custom_target(copy_compile_commands ALL
        COMMAND ${CMAKE_COMMAND} -E copy_if_different
            ${CMAKE_BINARY_DIR}/compile_commands.json
            ${CMAKE_SOURCE_DIR}/compile_commands.json
        COMMENT "Copying compile commands for IDE support..."
    )
endif()Please try not to overcomplicate suggestions. Do not hallucinate Pi Pico SDK 
functions, or MicroROS functions. Consider and provide information regarding the speed of solutions. 
Double check all suggestions provided to CMakeLists.txt
